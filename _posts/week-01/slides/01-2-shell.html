<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Week 1 - Lecture 2 - Shell Intro</title>
    <meta charset="utf-8" />
    <script src="libs/header-attrs/header-attrs.js"></script>
    <link href="libs/remark-css/default.css" rel="stylesheet" />
    <link href="libs/remark-css/default-fonts.css" rel="stylesheet" />
    <link href="libs/font-awesome/css/fontawesome-all.min.css" rel="stylesheet" />
    <link rel="stylesheet" href="slides.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">

class:inverse middle center



## *Week 1*
----
# An Introduction to the Unix shell
## *CSB Ch. 1: Unix*

&lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt;

### Jelmer Poelstra
### 2021/01/14 (updated: 2021-01-11)

---
class: inverse middle center

# Overview

----

.pull-left[
### [Ch. 1.1-1.2 &amp;ndash; Intro](#shell-intro)
### [Ch. 1.3 &amp;ndash; Getting started: Unix](#unix-intro)
### [Ch. 1.4 &amp;ndash; Getting started: Shell](#shell-intro)
### [Ch. 1.5 &amp;ndash; Basic commands](#basic)
]

.pull-right[

### [Ch. 1.6 &amp;ndash; Advanced commands](#advanced)
### [Wrap-up &amp; The Unix philosophy](#wrap-up)
### [*Bonus material*](#bonus)
]

&lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt;

---
class: inverse middle center
name: shell-intro

# Ch. 1.1-1.2 &amp;ndash; Intro

----
&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;

---

## Why use the Unix shell?

- **Using software**  
  Best or only option to use many programs, especially in bioinformatics.

- **Automation and fewer errors**  
  The shell allows you to repeat and automate tasks easily
  and without introducing errors.

- **Reproducibility**  
  The shell keeps a record of what you have done.

- **Remote computing &amp;ndash; especially HPCs**  
  Often not possible to do *anything* outside of the terminal. 

--

### Versus scripting languages like Python or R

- For many simpler tasks, built-in shell tools are faster &amp;mdash;  
  writing time, processing time, ease of processing very large files.

- *Direct* interface to other programs.

---

## Accessing a shell at OSC

1. Go to &lt;https://ondemand.osc.edu&gt; in your browser, and log in.

2. Click on `Clusters` and then `Pitzer Shell Access`.

--

&lt;br&gt;

.content-box-info[
You can't right-click in this shell-in-the-browser, but:

- To **paste**, use &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;V&lt;/kbd&gt;.

- To **copy**, simply select text and you should see a
  <i class="fas  fa-cut "></i> icon. 
]

---
class: inverse middle center
name: unix-intro

# Ch. 1.3 &amp;ndash; Getting started with Unix

----

&lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt;

---

## Ch. 1.3 &amp;ndash; Unix directory structure

- The Unix directory structure is hierarchical, with a single starting point:  
  the **root**, depicted as **`/`**.
  
- `/bin` and also `/usr/bin` contains *bin*aries: executable programs.

--

&lt;br&gt;

- At OSC, our home dir is not `/home/&lt;username&gt;` &amp;ndash; but can, as always,  
    be accessed using **`$HOME`** or **`~`**.
  ```sh
  $ echo $HOME    # The "echo" command prints text to screen
  $ echo ~
  ```

  .content-box-info[
  **`$HOME`** is an *environment variable*, like **`$USER`**, which contains your  
  username (we'll be using that one a lot).
  ]

---
class: inverse middle center
name: shell-intro

# Ch. 1.4 &amp;ndash; Getting started with the shell

----

&lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt;

---

## 1.4.1 &amp;ndash; The `cal` command as an example

- Invoke `cal` without options or arguments:
  ```sh
  $ cal
  ```

- Provide the *argument* `2020`:
  ```sh
  $ cal 2020
  ```

- Use the *option* `-j` for a Julian calendar:
  ```sh
  $ cal -j
  ```

- Also use the `-3` option, to show 3 months:
  ```sh
  $ cal -j -3
  
  $ cal -j3      # You can also combine options like this
  ```

---

## 1.4.1 &amp;ndash; Command structure

&lt;p align = "center"&gt;
&lt;img src=img/command-structure.png width="90%"&gt;
&lt;/p&gt;

.content-box-info[
- At least one space between a command and its options/arguments is required.

- `[]` indicates that an option or argument is *optional*.
]

---

## 1.4.2 &amp;ndash; Getting help

- Most commands have a **`man`**ual entry:
  ```sh
  $ man cal
  ```

  .content-box-info[
  Type `q` to exit the pager that `man` launches.
  ]

&lt;br&gt;

- Many commands &amp;ndash; *and other programs!* &amp;ndash; have a **`-h`**/**`--help`**
  option,  
  which tends to give a more concise summary of available options:
  ```sh
  $ cal -h
  $ cal --help
  ```

---

## 1.4 &amp;ndash; Keyboard shortcuts

### Most keyboard shortcuts for efficiency, some invaluable:

  - `Up` / `Down` arrow keys to cycle through command history.

  - `Ctrl + C` to kill the currently running command. Try this:
    
    ```sh
    # For each, see what happens, then press Ctrl + C
    $ sleep 60s
    
    $ echo "Missing quote"  # Omit closing quote!
    ```
  
  - `Ctrl+D` or typing `exit` will exit a shell.

&lt;br&gt;

--

.content-box-warning[
Another shell shortcut you may be aware of is **`Ctrl+W`**,  
which cuts the *word* behind the cursor &amp;ndash; but in a browser,  
it closes your tab!
]

---

## 1.4 &amp;ndash; Practicing keyboard shortcuts

- Tab completion:
  
  - Type **`/f`** and press &lt;kbd&gt;Tab&lt;/kbd&gt; (will autocomplete to */fs/*)
  
  - Then add **`e`** (*/fs/e*) and press &lt;kbd&gt;Tab&lt;/kbd&gt;.
  
  - Add **`PAS`** (*/fs/project/PAS*) and press &lt;kbd&gt;Tab&lt;/kbd&gt; &lt;kbd&gt;Tab&lt;/kbd&gt;.
  
  - Add **`185`** (*/fs/project/PAS18*) and press &lt;kbd&gt;Tab&lt;/kbd&gt; &lt;kbd&gt;Tab&lt;/kbd&gt;.
  
  - Complete it to */fs/project/PAS1855* but don't press &lt;kbd&gt;Enter&lt;/kbd&gt;.

---

## 1.4 &amp;ndash; Practicing keyboard shortcuts (cont.)

- Press &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;A&lt;/kbd&gt; to move to the beginning of the line,   
  and add **`ls`** to the beginning: `ls /fs/project/PAS1855`.  
  
  Press &lt;kbd&gt;Enter&lt;/kbd&gt; (anywhere on the line!).

--

&lt;br&gt;

- Press &lt;kbd&gt;&amp;#8679;&lt;/kbd&gt; to get the previous command back on the prompt,  
  and then press &lt;kbd&gt;Ctrl+U&lt;/kbd&gt; to delete until the beginning of the line.
  
- &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;U&lt;/kbd&gt; actually *cut* the text:
  "Yank" it back with &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Y&lt;/kbd&gt;.


---

## 1.4 &amp;ndash; Getting set up

.content-box-info[
**Our base OSC directory for the course:**  
`/fs/ess/PAS1855/`
]

- Create a directory for yourself using `mkdir`:
  ```sh
  $ mkdir /fs/ess/PAS1855/users/$USER
  ```
  
- Move into this dir using `cd` &amp;ndash; after typing `cd` and a space,
  press &lt;kbd&gt;Alt&lt;/kbd&gt;+&lt;kbd&gt;.&lt;/kbd&gt;:
  ```sh
  $ cd /fs/ess/PAS1855/users/$USER
  ```

--

- Get the files associated with the CSB book by "*cloning*" the Git repo:

  ```sh
  $ git clone https://github.com/CSB-book/CSB.git
  ```

- Move into the *sandbox* dir for the Unix chapter:
  ```sh
  $ cd CSB/unix/sandbox # Use tab completion
  ```

---

## 1.4.3 &amp;ndash; Navigation

- To see where you are, **`pwd`** will **`p`**rint **`w`**orking **`d`**ir: 
```sh
pwd
```

- Use **`cd`** to **`c`**hange **`d`**irectory, here with an *absolute path*
  (starting from **`/`**):
  ```sh
  $ cd /fs/ess/PAS1855/users/$USER/CSB/python/data
  ```

- We'll try a *relative path* to move back:
  ```sh
  $ cd ../../unix/sandbox
  ```

- Move back and forth using `cd -`:
  ```sh
  $ cd -    # Back to python/data
  $ cd -    # Back to unix/sandbox
  ```

---

### 1.4.3 &amp;ndash; Navigation shortcuts

```sh
$ cd ~      # Move to your home dir

$ cd ..     # Move one dir up
$ cd ../..  # Move two dirs up (sequence can be expanded)

$ cd -      # Go back to last visited dir (like "Back" in a browser)

$ cd .      # This doesn't move you anywhere, as `.` is a shortcut
            # for the current working directory (useful elsewhere)
```

&lt;br&gt;

.content-box-info[
All except the **`-`** are *general shell shortcuts* that work with other
commands, too (e.g., `ls ..`).
]

---
class: inverse middle center
name: basic

# Ch. 1.5 &amp;ndash; Basic Unix commands

----

&lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt;

---

## 1.5.1 &amp;ndash; Handling directories and files

- Use **`cp`** to **`c`**o**`p`**y files and optionally directories:
  ```sh
  $ cp ../data/Buzzard2015_about.txt \
      /fs/ess/PAS1855/users/$USER/CSB/unix/sandbox/
      
  $ cp ../data/Buzzard2015_about.txt .  # . for current dir
  ```

  .content-box-info[
  **`\`** can be used to continue a command on another line:  
  it "escapes" the newline character.
  ]

---

## 1.5.1 &amp;ndash; Handling directories and files

- Use **`cp`** to **`c`**o**`p`**y files and optionally directories:
  ```sh
  $ cp ../data/Buzzard2015_about.txt \
      /fs/ess/PAS1855/users/$USER/CSB/unix/sandbox/
      
  $ cp ../data/Buzzard2015_about.txt .  # . for current dir
  ```

  .content-box-warning[
  We overwrote the first copy of the Buzzard file with the second,  
  and the shell did not warn us about it (!).  
  (To prevent this behavior, use `set -o noclobber`.)
  ]

---

## 1.5.1 &amp;ndash; Handling directories and files

- Use **`cp`** to **`c`**o**`p`**y files and optionally directories:
  ```sh
  $ cp ../data/Buzzard2015_about.txt \
      /fs/ess/PAS1855/users/$USER/CSB/unix/sandbox/
      
  $ cp ../data/Buzzard2015_about.txt .  # . for current dir
  ```

- Copy using a new name for the copy:
  ```sh
  $ cp ../data/Buzzard2015_about.txt buzz2.txt
  ```

- The `-r` option is needed for recursive copying:
  ```sh
  $ cp -r ../data . 
  ```

---

## 1.5.1 &amp;ndash; Handling directories and files (cont.)

- Use **`mv`** both to **`m`**o**`v`**e and rename files (this is really the same operation):
  ```sh
  $ mv buzz2.txt buzz_copy.txt
  
  $ mv Buzzard2015_about.txt ../data/
  ```  

  .content-box-info[
  `mv` works for directories without the need to specify an option.
  ]

&lt;br&gt;

.content-box-answer[
For both `cp` and `mv`:
- If the destination is an existing dir, the file will keep its name.
- If it is not an existing dir, the path specifies the new name. 
]

---

## 1.5.1 &amp;ndash; Handling directories and files (cont.)

- **`rm`** **`r`**e**`m`**oves files:
  ```sh
  $ rm buzz_copy.txt
  ```

- Like with `cp`, the **`-r`** option is needed to work on dirs:
  ```sh
  $ mkdir -p d1/d2/d3 # mkdir -p to create multiple levels at once
  $ rm d1             # NOPE
  $ rm -r d1
  ```

--

&lt;br&gt;

  .content-box-warning[
  There is no thrash bin when deleting files in the shell,  
  so use `rm` with caution!
  ]

```sh
$ cd ../data   # Move to the data dir for the next commands
```

---

## 1.5.2 &amp;ndash; Viewing and processing text files

- **`cat`** will print one or more files:
  ```sh
  $ cat Marra2014_about.txt Gesquiere2011_about.txt
  ```

- **`wc`** will count lines, words, and characters by default &amp;ndash;  
  but is used mostly to just count lines with the `-l` option:
  ```sh
  $ wc -l Marra2014_about.txt
  ```

--

- **`head`** and **`tail`** will print the first or last lines of a file:
  ```sh
  $ head Gesquiere2011_data.csv         # Default: first 10 lines
  $ tail -n 2 Gesquiere2011_data.csv
  ```
  
  - A neat trick to *start at* a specific line,
    here to skip the header:
    ```sh
    $ tail -n +2 Gesquiere2011_data.csv
    $ tail -n +2 Gesquiere2011_data.csv | head # Easier to check
    ```

---
class: inverse middle center
name: advanced

# Ch. 1.6 &amp;ndash; Advanced Unix commands

----

&lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt;

---

## 1.6.1 &amp;ndash; Redirection and pipes

### Standard output and redirection

- The regular output of a command is called **"standard out"** ("*stdout*").   
  By default, this is printed to screen,
  but it can be "*redirected*" to a file.

- With "**`&gt;`**", we **redirect** output to a file:
  - If the file doesn't exist, it will be *created*.
  - If the file does exist, any contents will be *overwritten*. 
  
  ```sh
  $ cd ../sandbox
  $ echo "My first line"
  $ echo "My first line" &gt; test.txt
  $ cat test.txt
  ```

--

- With "**`&gt;&gt;`**", we **append** the output to a file:
  ```sh
  $ echo "My second line" &gt;&gt; test.txt
  $ cat test.txt
  ```

---

## 1.6.1 &amp;ndash; Redirection and pipes

### Standard input and pipes

- A file name can be given as an argument to most commands:

  ```sh
  $ ls ../data/Saavedra2013/ &gt; filelist.txt
  $ cat filelist.txt
  $ wc -l filelist.txt
  ```

--

- Most commands *also* accept input from "standard input" (*stdin*)   
  using the **pipe**, "**`|`**":
  
  ```sh
  $ ls ../data/Saavedra2013/ | wc -l
  ```

&lt;br&gt;

.content-box-info[
Pipes avoids the need write/read files &amp;ndash;
this saves typing,  
and not writing/reading also makes the operation much quicker.
]

---

## 1.6.2 &amp;ndash; Selecting columns using `cut`

- Let's have a look at the data first:
  ```sh
  $ cd ../data
  $ head -n 2 Pacifici2013_data.csv
  ```
- To select a column, specify the specify the column *delimiter* with **`-d`**,
  and the numbers of the desired columns (or *fields*) with **`-f`**:
  ```sh
  $ cut -d ";" -f 1 Pacifici2013_data.csv | head -n 3
  ```

--

- To select multiple columns, use a range or comma-delimited list:
  ```sh
  $ cut -d ";" -f 1-4 Pacifici2013_data.csv | head -n 3
  $ cut -d ";" -f 2,8 Pacifici2013_data.csv | head -n 3
  ```

--

.content-box-info[
Unfortunately, we can't *reorder* columns using `cut`.
]

---

## 1.6.2 &amp;ndash; Combining `cut`, `sort`, and `uniq` &lt;br&gt; to create a list

Let's say we want an alphabetically sorted list of animal *orders* from
the `Pacifici2013_data.csv` file...

- First, we select our column of interest, and get rid of the header line:
  ```sh
  $ cut -d ";" -f 2 Pacifici2013_data.csv | \
      tail -n +2 | \
  ```

- Next, we pipe to `sort` to sort the result, and then to `uniq` to only
  keep unique rows (values):
  
  ```sh
  $ cut -d ";" -f 2 Pacifici2013_data.csv | \
      tail -n +2 | \
      sort | uniq
  ```

.content-box-info[
`uniq` only works (as you intend it to) on sorted data.
]

---
name: tr

## 1.6.3 &amp;ndash; Substituting characters using `tr`

- `tr` for **`tr`**anslate will substitute characters &amp;ndash; here,
  any `a` for a `b`:
  ```sh
  $ echo "aaaabbb" | tr a b
  ```

- `tr` also works well with multiple values and replacements:

  ```sh
  echo "123456789" | tr 1-5 0    # Replace any of 1-5 with 0
  
  # One-to-one mapping of input and replacement!
  $ echo "ACtGGcAaTT" | tr actg ACTG
  # ACTGGCAATT
  $ echo "aabbccddee" | tr a-c 1-3
  # 112233ddee
  ```

--

- Deletion and "squeezing":
  ```sh
  $ echo "aabbccddee" | tr -d a  # Delete all a's
  # bbccddee
  $ echo "aabbccddee" | tr -s a  # Remove consecutive duplicates
  # abbccddee
  ```

---

## 1.6.3 &amp;ndash; Substituting characters using `tr` (cont.)

- `tr` does not take file names as an argument,  
  so how can we provide it with input from a file?

--

  - Using a pipe:  
  ```sh
  $ cat inputfile.csv | tr " " "\t" &gt; outputfile.csv
  ```
  - By *redirecting* the input (**`&lt;`**):
  ```sh
  $ tr " " "\t" &lt; inputfile.csv &gt; outputfile.csv
  ```

&lt;br&gt;

.content-box-info[
In, **`\t`**, the **`\`** gives the **`t`** a special meaning: **`Tab`**.  
We'll talk more about regular expressions later.
]

---

## 1.6.5 &amp;ndash; `grep` to print lines matching a pattern

- Print all lines containing "Vombatidae":
  ```sh
  $ grep "Vombatidae" Pacifici2013_data.csv
  ```

- Print all lines *not* containing "Vombatidae":
  ```sh
  $ grep -v "Vombatidae" Pacifici2013_data.csv  # v for inVert
  ```

.content-box-info[
- It is best to always use quotes around the pattern
- Incomplete matches work: "`Vombat`" matches `Vombatidae`
]

--

- **Many other useful options &amp;mdash; more in Week 4:**
  
  - `-c` to count matches
  - `-i` to ignore case
  - `-r` to search file recursively -- **very useful**
  - `-B` and `-A` to print lines surrounding matches
  - `-w` to match "words"
  
---
class: inverse middle center
name: wrap-up

#  Wrap-up &amp; the Unix philosophy

----

&lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt;

---

## Covered in the chapter but not in the slides

- The `less` pager to view files

- The `find` command to find files

- Showing and changing file permissions

- Basic shell scripting

- `for` loops

- `$PATH` and bash profile settings

&lt;br&gt;

**We'll cover all of these in class over the next few weeks.**

---

## The Unix philosophy

&gt; *This is the Unix philosophy: Write programs that do one thing and do it well.*
&gt; *Write programs to work together. Write programs to handle text streams,*
&gt; *because that is a universal interface.*&lt;br&gt;
&gt; — Doug McIlory

&lt;br&gt;

--

### Advantages of a modular approach

- Easier to spot errors

- Easy to swap out components, including in other languages

- Easier to learn (?)

---

## The Unix philosophy

&gt; *This is the Unix philosophy: Write programs that do one thing and do it well.*
&gt; *Write programs to work together. Write programs to handle text **streams**,*
&gt; *because that is a universal interface.*&lt;br&gt;
&gt; — Doug McIlory

&lt;br&gt;

### Text "streams"?

Rather than loading entire files into memory, process them one line at a time.
Very useful with large files!

```sh
$ cat *.fa &gt; combined.fa
```

---

## Looking Ahead

- Next two weeks, primary focus on project organization and then Git,  
  with more shell practice and tools along the way.

- In weeks 4-6, we'll fully focus on the shell and shell scripting.

&lt;br&gt;

--

.content-box-info[
If you're feeling a bit overwhelmed,
note that we will repeat lots of today's content in week 4 (Buffalo chapter 7).
]

---
class: inverse middle center

# Questions?

----

&lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt;

---
class: inverse middle center
name: bonus

# Bonus Materials

----

&lt;br&gt;

### [Keyboard shortcuts &amp; tricks](#keyboard-shortcuts)
### [Other CSB-Ch.1 sections, and "uniq -c" bonus](#uniqc)
&lt;br&gt; &lt;br&gt; &lt;br&gt;

---
background-color: #f2f5eb
name: keyboard-shortcuts

## Keyboard Shortcuts and Tricks I

| Shortcut | Command | Function
|--|--|
| `Tab` | | Tab completion! Files, commands, etc. &lt;br&gt; Double `Tab` to show options when &lt;br&gt; multiple are still available.|
| Up/Down arrow | | Cycle through command history|
| `CTRL` + `R` | | Enter characters to search for in the history &lt;br&gt; (repeat `CTRL` + `R` to keep going back, &lt;br&gt; `ENTER` to put command in prompt) |
| `CTRL` + `C` | | Abort (kill) current process |
| `CTRL` + `D` | `exit` | Exit the current shell (/ interactive job) |
| `CTRL` + `Z` | (`bg` / `fg`)| Suspend (pause) a process, &lt;br&gt; then use `bg` to move to background|

---
background-color: #f2f5eb

## Keyboard Shortcuts and Tricks II

| Shortcut | Function
|--|--|
| `Ctrl` + `Shift` + `c`  | Copy |
| `Ctrl` + `Shift` + `v`  | Paste |
| `Ctrl` + `a` | Go to beginning of line |
| `Ctrl` + `e` | Go to end of line |
| `Ctrl` + `u` | Cut to beginning of line |
| `Ctrl` + `k` | Cut to end of line |
| `Ctrl` + `w` | Cut previous word |
| `Ctrl` + `y` | Paste previously cut element |
| **`Alt` + `.`** | Paste last argument of last command |

- For the last one, can also use `!$`:

  ```sh
  mkdir -p ~/long/path/I/dont/want/to/retype.txt
  cd !$
  ```

---
background-color: #f2f5eb

## 1.4.3 &amp;ndash; The trouble with spaces

- Because spaces are special characters used to separate commands from options
  and arguments, etc., using them in file names is inconvenient at best:
  
  ```sh
  # You should be in /fs/ess/PAS1855/users/$USER/CSB/unix/sandbox
  ls
  
  cd Papers and reviews     # NOPE!
  
  cd Papers\ and\ reviews   # \ to escape each individual space
  cd "Papers and reviews"   # Quotes to escape special characters
  ```

  .content-box-info[
  We'll talk about spaces and file names in week 2.
  ]

---
background-color: #f2f5eb
name: uniqc

## 1.6.2 &amp;ndash; Selecting Columns Using `cut`: Bonus

- Use `uniq -c` to count occurrences of each unique value!
  ```sh
  $ cut -d ";" -f 2 Pacifici2013_data.csv | tail -n +2 | sort \
         | uniq -c
  #   54 Afrosoricida
  #  280 Carnivora
  #  325 Cetartiodactyla
  # 1144 Chiroptera
  #   21 Cingulata
  ```
  
  ```sh
  $ cut -d ";" -f 2 Pacifici2013_data.csv | tail -n +2 | sort \
         | uniq -c | sort -nr
  # 2220 Rodentia
  # 1144 Chiroptera
  #  442 Eulipotyphla
  #  418 Primates
  ```

  .content-box-info[
  We'll see `uniq -c` again in week 4.
  ]

---
background-color: #f2f5eb

## 1.6.3 &amp;ndash; Building a Unix pipeline with `tr` and others

Let's say we want a list of animals sorted by body weight...

```sh
$ cd ../sandbox/
$ tail -n +2 ../data/Pacifici2013_data.csv
```

- Select the columns of interest with `cut`:
  ```sh
  $ tail -n +2 ../data/Pacifici2013_data.csv | \
  cut -d ";" -f 2-3 | head # Using head just to check
  ```

- Change the *delimiter* with `tr`:
  ```sh
  $ tail -n +2 ../data/Pacifici2013_data.csv | \
      cut -d ";" -f 5-6 | tr ";" " " | head
  ```

- Sort in reverse numerical order with `sort`,
  and redirect output to a file:
  ```sh
  $ tail -n +2 ../data/Pacifici2013_data.csv | \
      cut -d ";" -f 5-6 | tr ";" " " | sort -r -n -k 3 &gt; BodyM.csv
  $ head BodyM.csv
  ```

---
background-color: #f2f5eb

## 1.6.4 &amp;ndash; Wildcards

### Use wildcards with any command to match file names of interest:

- **`*`** will match any number (including zero) of any character,  
  and **`?`** will match any *single* character.

  ```sh
  cd ~/CSB/unix/data/miRNA
  
  # Match any file ending in ".fasta":
  wc -l *.fasta
  
  # Match any file starting with "pp"
  head -n 2 pp*
  
  # Match any file ending in a period and then three characters:
  file *.???
  ```

  .content-box-info[
  We'll talk more about wildcards in week 2.
  ]
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "rainbow",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
