<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Week 2 - Part II - Managing Files in the Shell</title>
    <meta charset="utf-8" />
    <script src="libs/header-attrs/header-attrs.js"></script>
    <link href="libs/remark-css/default.css" rel="stylesheet" />
    <link href="libs/remark-css/default-fonts.css" rel="stylesheet" />
    <link href="libs/font-awesome/css/fontawesome-all.min.css" rel="stylesheet" />
    <link rel="stylesheet" href="slides.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">

class:inverse middle center



## *Week 2: &lt;br&gt; Project Organization and Markdown*
----
# Part II: Managing Files in the Shell

&lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt;

### Jelmer Poelstra
### 2021/01/19 (updated: 2021-01-10)

---
class: center middle inverse

# Overview

----

.pull-left[
### [VS Code setup](#osc-vscode)
### [Wildcard expansion](#wildcard)
### [Brace expansion](#brace)
]
.pull-right[
### [File permissions](#permissions)
### [File renaming](#file-renaming)
]

---
name:osc-vscode

## Starting *VS Code* at OSC

1. Go to &lt;https://ondemand.osc.edu&gt; in your browser, and log in.

2. Click on `Interactive Apps` in the blue top bar.

3. Near the bottom, click `Code Server`.

4. In the form:
   - Under `Number of hours`, select 1 or 2 hours.
   - Under `Working directory`, type `/fs/ess/PAS1855`.

5. Click the blue `Launch` button, and you'll move to a different page.

5. Once the top bar of the box is green, and click `Connect to VS Code`.

&lt;p align="center"&gt;
&lt;img src=img/w01/osc-code-launch.png width="55%"&gt;
&lt;/p&gt;

---

## Getting VS Code ready

**We need to start with a bit of housekeeping:**

1. Gain screen real estate by toggling off the Side Bar by pressing `Ctrl+B`.

2. Open a Terminal by pressing &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;backtick&lt;/kbd&gt; or
   &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Shift&lt;/kbd&gt;+&lt;kbd&gt;C&lt;/kbd&gt;.
  
3. Close the "Welcome" tab (click the `X`) and pull up the terminal's dividing
   line to the top of your window.

4. In the terminal, the prompt says `Singularity&gt;`. This means we are inside a
   Singularity container. **Type `bash` to exit the container.**

Finally, we're ready to go...

## TO DO: START TEXT DOCUMENT

&lt;br&gt;

--

.content-box-warning[
In *VS Code*, there are default existing bindings for the
&lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;K&lt;/kbd&gt; (*cut to end of line*) and 
&lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;E&lt;/kbd&gt; (*go to end of line*) combinations,
so they won't be interpreted by the shell.
If you have an &lt;kbd&gt;end&lt;/kbd&gt; key, that will also work to move to the end of
the line.
]

---

## Create a dummy project &amp;ndash; following Buffalo

- Go to your starting point dir:
  ```sh
  cd /fs/ess/PAS1855/users/$USER
  ```
  
- Create the directory structure:

  ```sh
  $ mkdir zmays-snps
  $ cd zmays-snps
  $ mkdir -p data/seqs scripts analysis
  ```

--

- Create some empty "sequence files":
  ```sh
  $ cd data/seqs
  $ touch sample1_F.fastq.gz sample1_R.fastq.gz \
        sample2_F.fastq.gz sample2_R.fastq.gz \
        sample3_F.fastq.gz sample3_R.fastq.gz
  ```

--

- For a nice overview of your directory structure:

  ```sh
  tree
  ```

---

## Shell expansion I: Wildcard expansion

|Wildcard | Matches |
|-|-|
| * | Any number of any character, including nothing |
| ? | Any single character 
| [] and [^] | One or none (`^`) of the "character set" within the brackets   

--

- With the following files in a directory:
  ```sh
  # sample1_F.fastq.gz sample1_R.fastq.gz
  # sample2_F.fastq.gz sample2_R.fastq.gz
  # sample3_F.fastq.gz sample3_R.fastq.gz
  ```

--

- **To match both "*sample1*" files:**
  ```sh
  ls sample1_?.fastq.gz
  ls sample1*
  ls sample1*fastq.gz
  ```

---

## Shell expansion I: Wildcard expansion (cont.)

|Wildcard | Matches |
|-|-|
| * | Any number of any character, including nothing |
| ? | Any single character 
| [] and [^] | One or none (`^`) of the "character set" within the brackets   

- With the following files in a directory:
  ```sh
  # sample1_F.fastq.gz sample1_R.fastq.gz
  # sample2_F.fastq.gz sample2_R.fastq.gz
  # sample3_F.fastq.gz sample3_R.fastq.gz
  ```

- **To match only files with forward (*"F"*) reads:**
  ```sh
  $ ls *F*
  $ ls *F.fastq.gz
  ```

---

## Shell expansion I: Wildcard expansion (cont.)

|Wildcard | Matches |
|---------|---------|
| * | Any number of any character, including nothing |
| ? | Any single character 
| [] and [^] | One or none (`^`) of the "character set" within the brackets   

- With the following files in a directory:
  ```sh
  # sample1_F.fastq.gz sample1_R.fastq.gz
  # sample2_F.fastq.gz sample2_R.fastq.gz
  # sample3_F.fastq.gz sample3_R.fastq.gz
  ```

- **To match files for sample1 and sample2 only using a character class:**
  ```sh
  $ ls sample[12]*   # Use the character class notation
  $ ls sample[1-2]*  # Can use ranges like [0-9], [A-Z], [a-z].
  $ ls sample[^3]*   # Other way around: exclude sample3
  ```

--

  .content-box-warning[
  `[]` works on character ranges only: 0-9 works; 10-13 does not.
  ]

---

## Shell expansion I: Wildcard expansion (cont.)

- Wildcards are only used to match (or *expand to*) file names.  
  (This process is also called *"globbing"*.)
  
- Why do we call this a type of _**shell** expansion_?

--

  - The expansion &amp;ndash;to all matching file names&amp;ndash; is done *by the shell*,   
    **not** by `ls` (or other commands you might be using wildcards with).

  - That is, `ls` will see the list of files after the expansion.

--

&lt;br&gt;

- When using shell expansion to *move* or *delete* files,
  it is useful to first check what your command will "see",
  using `ls` or `echo`:
  
  ```sh
  echo sample[12]*
  ```
--

.content-box-info[
Examples so far may seem trivial but you can use these techniques to easily pull out files among 100s or 1000s of files.
]

---

## Shell expansion I: Wildcard expansion (cont.)

- **Don't confuse wildcards with regular expressions!**

  - What do **`*`** and **`?`** mean in regular expressions?

&lt;br&gt;

- Regular expressions are useful across the board in programming,  
  and we will have a Python module devoted to them (week 11).

---

## Shell expansion II: Brace expansion

- *Wildcard expansion* looks for corresponding files
    and expands to whichever files are present:
    can't be used to create files or dirs.

- **_Brace expansion_**, on the other hand, expands to whatever you tell it to.  

&lt;br&gt;

- Use `..` to indicate ranges:
  ```sh
  $ mkdir -p data/obs_2021-01-{01..31} # Numeric range works!
  
  $ touch plot-{A..F}                  # Character range works
  ```

- Use a comma-separated list:
  ```sh
  $ mkdir -p fig-{small,medium,large}-{color,grayscale}
  ```

---

## Shell expansion II: Brace expansion

- *Wildcard expansion* looks for corresponding files
    and expands to whichever files are present:
    can't be used to create files or dirs.

- **_Brace expansion_**, on the other hand, expands to whatever you tell it to.  

.content-box-q[
What will happen in these two case?
  
  ```sh
  $ # touch plot-{A..F}
  
  $ ls plot-[A-G]
  
  $ ls plot-{A..G}
  ```
]

---

## Shell expansion II: Brace expansion

- *Wildcard expansion* looks for corresponding files
    and expands to whichever files are present:
    can't be used to create files or dirs.

- **_Brace expansion_**, on the other hand, expands to whatever you tell it to.  
  
.content-box-answer[
- Wildcard expansion will ignore the missing "*plot-G*":
```sh
$ ls plot-[A-G]
# plot-A  plot-B  plot-C  plot-D  plot-E  plot-F
```

- Brace expansion will complain about the missing "*plot-G*":
```sh
$ ls plot-{A..G}
# ls: cannot access 'plot-G': No such file or directory
# plot-A  plot-B  plot-C  plot-D  plot-E  plot-F
```
]

---
background-color:#e4ede4

## <i class="fas  fa-user-edit "></i> Your turn: File matching

1. Create a dir `week02/sandbox/` and move into it.

2. Using *brace expansion* and the **`touch`** command,
  create empty `R1` and `R2` fastq files for 100 samples with IDs from `001`
  to `100`: `sample&lt;ID&gt;_R1_001.fastq` and `sample&lt;ID&gt;_R2_001.fastq`.

3. Using *wildcard matching* and by piping **`ls`** output into **`wc -l`**,
  count the number of "`R1`" files (forward reads).

4. **_Bonus:_** Copy all files *except the two for "`sample100`"* into a new
  directory called `selection` &amp;mdash;
  use a wildcard to do the move with a single command.
  (But you'll need to create the new dir first.)

---
background-color:#e4ede4

## Solutions: File matching

1. Create a dir `week02/sandbox/` and move into it:
```sh
mkdir week02/sandbox/
cd week02/sandbox/     # Use the Alt+. shortcut after `cd`
```

2. Create empty `R1` and `R2` fastq files for 100 samples:
```sh
touch sample{001..100}_R{1,2}_001.fastq
```

3. Count the number of `R1` files:
```sh
ls sample*R1*fastq | wc -l
ls *R1* | wc -l # This works but it's better to be restrictive
```

4. **_Bonus:_** Copy all files except "`sample100`" into a new dir called `selection`:
```sh
mkdir selection
mv sample[^1]* selection/
```

---

## Shell expansion III: Command substitution

- *Command substitution* allows you to store and pass the output of a command
  (or pipeline of commands) to another command.
  
  These two examples show how that can be useful and why a pipe wouldn't work:
  ```sh
  echo "There are $(wc -l data.csv) lines in my data file."
  # There are 87 lines in my data file.
    
  mkdir results_$(date +%F)
  # results_2021-01-05
  ```

## TODO: ADD A FILE

---

## Shell expansion III: Command substitution (cont.)

- We can also save a result in a *variable* or *array*:
  ```sh
  n_treatments=$(cut -f 2 data.csv | sort | uniq)
  echo ${n_treatments}   # Shorthand: "$n_treatments"
  
  treatments=$(cut -f 2 data.csv)
  echo ${treatments[@]}
  ```

---

## Special characters and escaping them

We've seen that the wildcards **`*`** and **`?`** have a special meaning.  

What if we had unwieldy file names,
and needed to match a *literal* **`*`** or **`?`**

--

- A **backslash** ("**`\`**") can be used to "escape" the special meaning
  of the character following the backslash:
  e.g. "**`\*`**" to match a literal "**`*`**".
  
  ```sh
  rm my\ bad\*file  # Tab autocomplete will work and insert \'s
  ```

--

- **Quoting** a string of characters will also escape special meaning
  of characters within them, with single quotes (**`'...'`**) being more severe
  than double quotes (**`"..."`**) &amp;mdash; more on this later. 

  ```sh
  rm 'my bad*file'
  ```

--

.content-box-info[
Backslashes can also *assign* special meaning
&amp;ndash; most common are **`\t`** (tab) and **`\n`** (newline).
We'll talk more about these *regular expressions* later.
]

  
---
class: inverse middle center

# Treating data as read-only:
# Viewing and modifying file permissions
----
&lt;br&gt;&lt;br&gt;&lt;br&gt;

---

## Showing file permissions

- To show file permissions, use **`ls`**  with the **`-l`** (*long* format)
  option.shows file permissions.
  
  (The command below also uses the **`-a`** option to show all files,
  including hidden ones, and **`-h`** shows file sizes in "human-readable"
  format.)

&lt;p align="center"&gt;
&lt;img src=img/w02/long-ls.png width="600"&gt;
&lt;/p&gt;

---

## File permissions (cont.)

.pull-left[
&lt;p align="left"&gt;
&lt;img src=img/w02/permissions.png width="300"&gt;
&lt;/p&gt;
]

.pull-right[
.content-box-info[
Generally, it is prudent to not give "others" write permissions.
]
]

--

- Can be changed in several ways with the `chmod` command:
  
  - `chmod &lt;who&gt;=&lt;set-permission&gt;`
  
  - `chmod &lt;who&gt;+&lt;add-permission&gt;`
  
  - Digits: 4 for read, 2 for write, 1 for execute &amp;ndash; e.g. 7 =&gt; all three.
  
  ```sh
  chmod u=rwx my-program     # user=read-write-execute
  chmod u=rw,go=r my-file    # user=read-write, group&amp;others=read 
  chmod a=r data/raw/*       # all=read
  chmod -R 744               # user: rwx, group&amp;others: read
  ```

---

## File permissions (cont.)

.pull-left[
&lt;p align="left"&gt;
&lt;img src=img/w02/permissions.png width="300"&gt;
&lt;/p&gt;
]

.pull-right[
.content-box-info[
Generally, it is prudent to not give "others" write permissions.
]
]

- Can be changed in several ways with the `chmod` command:
  
  - `chmod &lt;who&gt;=&lt;set-permission&gt;`
  
  - `chmod &lt;who&gt;+&lt;add-permission&gt;`
  
  - Digits: 4 for read, 2 for write, 1 for execute &amp;ndash; e.g. 7 =&gt; all three.
  
- **To make your raw data read-only:**
  ```sh
  chmod u-w data/raw/*       # Take away write permission
  
  chmod 400 data/raw/*       # User: read, group &amp; others: none
  ```

---

## Add -x necessary for dirs

---

## File permissions: Practice

- First, let's look at the original permissions of the files:
  ```sh
  cd week02/sandbox
  ls -l selection/
  ```

- Then, limit permissions for **a**ll to **r**ead, and check what we did:
  ```sh
  chmod a=r selection/
  ls -l selection/
  ```
--

- What happens when we try to remove write-protected files?
  ```sh
  rm selection/*
  
  rm -f selection/*  # Be careful with `rm -f`
  ```

.content-box-info[
While *you* (the file owner) can still remove write-protected files,
others really can't read/write/execute files without appropriate permissions.
]

---

## Sidenote: "The Unix Chainsaw"

- What will these two commands do?
  ```sh
  rm -rf tmp-data/aligned-reads*
  
  rm -rf tmp-data/aligned-reads *
  ```

&lt;br&gt;

--

- What are we removing with the last command?
  ```sh
  mkdir "raw sequences"
  mkdir sequences
  rm -rf raw sequences
  ```

---

## Programmatically renaming files

- Many different ways to do this in the shell,
  admittedly none as easy as one might have hoped for.
  
- Here, we'll use the `basename` command and a `for` loop.

- `basename` strips any dir name that may be present from a file name (path),
  and optionally, removes a suffix:
  ```sh
  basename selection/sample001_R1_001.fastq
  # sample001_R1_001.fastq
  
  basename selection/sample001_R1_001.fastq _001.fastq
  # sample001_R1
  ```

---

## Programmatically renaming files (cont.) 
  
- `for` loops are a verbose method for tasks like renaming,  
  but are intuitive and good practice.
  
  The following shows the basic syntax of a for loop,
  and how the variable that is looped over is *assigned* to `oldname`,
  but *recalled* as `${oldname}`:

  ```sh
  for oldname in *.fastq
  do
     echo "Old name: ${oldname}"
  done
  ```

--

.content-box-info[
Note how we are using *globbing* (wildcard file name matching)
to define what will be looped over.
]

---

## Programmatically renaming files (cont.) 
  
- `for` loops are a verbose way for tasks like renaming,  
  but are intuitive and good practice.
  
  Next, we assign a new name for each file, and **`echo`** the names as  
  a sanity check:
  
  ```sh
  for oldname in *.fastq
  do
     newname=$(basename $oldname _001.fastq).fq
     echo "Old/new name: $oldname $newname"
  done
  ```

---

## Programmatically renaming files (cont.) 
  
- `for` loops are a verbose way for tasks like renaming,  
  but are intuitive and good practice.
  
  Finally, we add the actual **`mv`** command:  

  ```sh
  for oldname in *.fastq
  do
     newname=$(basename $oldname _001.fastq).fq
     echo "Old/new name: $oldname $newname"
     mv $oldname $newname
  done
  ```

---
class: inverse middle center

# Questions?

----

&lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt;

---
class: inverse middle center
name: bonus

# Bonus Materials

----

&lt;br&gt;

### [More conditional file processing](#conditional)
### [Standard error](#stderr)
### [Other tricks from Buffalo Ch. 3](#tricks)

---
background-color: #ededed
name:conditional

## Bonus: More conditional file processing

Remove all empty files in a directory:

```sh
for i in *
do
   if [ ! -s $i ]
   then
      echo rm $i
   fi
done
```

&lt;br&gt;

--

Code similar to the above can be applied to many tasks,  
though this task can be achieved much more concisely using `find`:

```sh
find . -size 0 -delete
```

---
background-color: #ededed
name: stderr

## Standard Error

- When commands run into errors, they will print error messages.  
  
  Error messages are **not** part of standard out,   
  and instead represent a separate output stream: **"standard error"**.

--

- We can see this when we try to list a non-existing directory:
  ```sh
  ls -lhr solutions/ &gt; solution_files.txt 
  # ls: cannot access solutions.txt: No such file or directory
  ```

- The error was printed to screen. What about the file?

--

  ```sh
  $ ls
  # solution_files.txt
  $ cat solution_files.txt
  $                # We just get our prompt back - file is empty
  ```

---
background-color: #ededed

## Standard error (cont.)

- So, without redirection **(a)** versus with **`&gt;`** redirection **(b)**:
&lt;p align="left"&gt;
&lt;img src=img/w01/std-streams.png width="550"&gt;
&lt;/p&gt;

&lt;br&gt;
--

- But we *can* also redirect the standard error:
  ```sh
  ls -lhr solutions/ &gt; solution_files.txt 2&gt; errors.txt
  ls -lhr solutions/ &amp;&gt; out.txt # `&amp;&gt;`: combine stdout and stderr (bash only)
  ```

---
background-color: #ededed
name:tricks

## More tricks from Buffalo Chapter 3

- **`tee`**: Redirect standard out to file *and* to screen / into a pipe:
  ```sh
  program1 in.txt | tee intermediate-file.txt | program2 &gt; out.txt
  ```
  
&lt;br&gt;

- "Follow" a file, useful to monitor output of a long-running command:
  ```sh
  tail -f                 # Press `Ctrl + C` to stop
  ```
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "rainbow",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
