---
title: "Week 3: Git and Github"
output:
  xaringan::moon_reader:
    seal: false
    css: ["default", "default-fonts", "slides.css", "slides_copy.css"]
    lib_dir: libs
    nature:
      highlightStyle: rainbow
      highlightLines: true
      countIncrementalSlides: false
---
class:inverse middle center

```{r setup, include=FALSE}
options(htmltools.dir.version = FALSE)

knitr::opts_chunk$set(eval = FALSE)
```

## *Week 3: <br> Git and Github*

----

# Part II: Remotes, branching, and merging
## (CSB 2.5-2.7)

<br> <br> <br> <br> <br>

### Jelmer Poelstra
### 2021/01/28 (updated: `r Sys.Date()`)

---
class:inverse middle center

# Overview

----

.left[
- ### CSB 2.5: [Remote repos](#remote)
- ### CSB 2.6: [Branching and merging](#branch)
- ### CSB 2.7 : [Public repos](#public)
- ### [Some best practices](best-prac)
]

<br> <br>

---

## CSB 2.5: Remote repositories

We have been locally version-controlling our *originspecies* repo,  
but now we also want to **keep this repo online, on Github**, to:

- Share our work and/or

- Have an online backup and/or

- Collaborate with others

--

### CSB 2.5: Creating a Github repo
While we can interact with online repos using Git commands,  
we *can't create a new online repo* with the Git CLI.

So, we go to <https://github.com> to create a new repo.

.content-box-info[
VS Code actually provides functionality to create repos directly.
]

---

## CSB 2.5: Creating a Github repo (cont.)

1. Go to <https://github.com> and sign in.

2. In the right-hand side bar, click the green `New` button
   (next to Repositories).

3. In the box `Repository name`, we'll use the same name that we gave to our
   local repository: `originspecies` (*Note:* the names don't need to match up.)

4. Leave other options as they are.  
   (We're not added a README or other files, since we've already started a repo
   locally &ndash; that would make more sense when doing "online-first".)

5. Click `Create Repository`.

---

## CSB 2.5: Linking the local and remote repo's

<p align="center">
<img src=img/github-newrepo2.png width=70%>
</p>

- Note that you can click on the `HTTPS`/`SSH` button to change the URLs!

---

## CSB 2.5: Linking the local and remote repo's (cont.)

We go back to the shell in VS Code, where we'll enter the commands under
"*...or push an existing repository from the command line*" which is our use case.

Breaking these commands down:

- First, we tell Git to add a "remote" connection,
  using the `git remote` command.
  We provide three arguments to this command:
  
  - `add` &ndash; because we're adding a remote
  
  - `origin` &ndash; the nickname we're giving the connection.  
    This is an arbitrary name but is usually *origin* by convention.   
    (Note that a local repo can have multiple remote connections.)
  
  - The SSH URL to the Github repo.

  ```sh
  # git remote add <remote-nickname> <URL>
  $ git remote add origin git@github.com:<user>/originspecies.git
  ```

---

## CSB 2.5: Linking the local and remote repo's (cont.)

- Second, we rename the default branch from `master` to `main`
  (Github since recently uses `main` as the default branch):
  ```sh
  $ git branch -M main
  ```

- Third, we push our local repo to remote using `git push`.  
  Whenever we push a branch for the first time,
  we need to `-u` flag to set up an "upstream" counterpart:
  ```sh
  $ git push -u origin main
  ```

--

.content-box-info[
Without any arguments, `git push` pushes:
 - To & from the **currently active *branch*** (default: `master`/`main`)
 - To the **default remote connection**.

Therefore, from now on, we can mostly just use:

```sh
$ git push
```
]

---

## CSB 2.5: Updating the local repo and pushing to remote

- Back at Github, click on `Code` in the lower of the top bars.  
  Now, we can see the files that we just uploaded from our local repo.
  
<br>

- Click where it says `x commits` (should be 4) with a clock icon,  
  and you'll get an overview of commits somewhat like with `git log`.
  
  On the right hand side, there are three buttons for each commit:

  - Click the hash (hexadecimal ID) to see changes made by that commit.
  
  - Click the <kbd>< ></kbd> to see the state of the repo at the time
    of that commit.
  
  <figure>
  <p align="center">
  <img src="img/github-commits.png" width="35%">
  </p>
  </figure>

---


## CSB 2.5: Remote repos &ndash; Single-user workflow

In a single-user workflow, all changes are made in the *local repo*,
and the remote repo is simply periodically updated.

So, the interaction between local and remote is unidirectional:

<figure>
<p align="center">
<img src="img/buffalo-remote-uni.png" width="35%">
<figcaption>Figure from Buffalo (2015)</figcaption>
</p>
</figure>

---

## CSB 2.5: Remote repos &ndash; Single-user workflow (cont.)

With a single-user workflow, our workflow is only modified by occasional *pushing* to remote.

- Let's add a README.md file, and commit:
  ```sh
  $ echo "# Origin" > README.md
  $ echo "Repo for book draft on my new **theory**" >> README.md
  $ git add README.md
  $ git commit -m "Added a README"
  ```

- Now, we push to remote:
  ```sh
  $ git push
  ```

<br>

.content-box-info[
If we go back to Github, we show that the contents of the README.md
automatically shows up as a rendered Markdown file!
]

---

## CSB 2.5: Remote repos &ndash; Multi-user workflow

A multi-user workflow starts when a second user downloads (*clones*)  
the online repo, as in **(b)** below:

<figure>
<p align="center">
<img src="img/buffalo-remote-1.png" width="70%">
<figcaption>Figure from Buffalo (2015)</figcaption>
</p>
</figure>

---

## CSB 2.5: Remote repos &ndash; Multi-user workflow

- Then, the second user can push their changes to the shared remote **(a)**:

<figure>
<p align="center">
<img src="img/buffalo-remote-2a.png" width="70%">
<figcaption>Figure from Buffalo (2015)</figcaption>
</p>
</figure>

---

## CSB 2.5: Remote repos &ndash; Multi-user workflow

- Then, the second user can push their changes to the shared remote **(a)**:

<figure>
<p align="center">
<img src="img/buffalo-remote-2.png" width="70%">
<figcaption>Figure from Buffalo (2015)</figcaption>
</p>
</figure>

- To go full circle, the first user (you in this case) then *pulls* in
  the changes made by the second user **(b)**. 

---

## CSB 2.5: Remote repos &ndash; Multi-user workflow

.content-box-info[
**Recap:**  

With a multi-user workflow, changes made by different users are *shared via
the online copy of the repo.*

But **syncing is not automatic**:

- Changes to your local repo remain local-only until you **push** to remote.

- Someone else's changes to the remote repo do not make it into your
  local repo until you **pull** from remote.
]

---
class:inverse middle center

# CSB 2.6

----

# Branching and merging

<br> <br> <br> <br> <br>

---

## CSB 2.6: Branching and merging &ndash; Code-along

- First, we create a dummy repo with a few commits by running a script:
  ```sh
  $ less ../data/create_repository.sh  # press `q` to exit less
  
  $ ../data/create_repository.sh
  ```

- Let's see what has been done in this repo:
  ```sh
  $ cd branching_example
  
  $ git log --oneline
  ```

--

<br>

- We want to improve the code, but these changes are experimental, and we want
  to retain our previous version that we know works.
  
  This is where ***branching*** comes in &ndash; we create a new branch as
  follows:
  ```sh
  $ git branch fastercode   # We name the branch "fastercode"
  ```
 
---

## CSB 2.6: Branching and merging &ndash; Code-along

- Let's see what our log looks like now, and list the branches:
  ```sh
  $ git log --oneline
  ```
  
  ```sh
  $ git branch  # Without args, will list the branches
  ```

--

- It turns out we created a new branch **but we are still on the master branch**,
  so we should switch branches:
  ```sh
  $ git checkout fastercode  # Note reuse of `checkout` command!
  ```

- We edit the code, stage and commit the changes:
  ```sh
  $ echo "Yeah, faster code" >> code.txt
  $ git add code.txt
  $ git commit -m "Managed to make code faster"
  ```

- Let's check the log again:
  ```sh
  $ git log --oneline # Last commit: on branch "fastercode"
  ```

---

## CSB 2.6: Branching and merging &ndash; Code-along

- We need to switch gears completely within the project,
  and add references to the paper draft.
  
  Since this has nothing to do with our attempt at faster code,
  we should make these changes back on the `master` branch:
  
  ```sh
  # Move back to master:
  $ git checkout master
  
  # Add the reference:
  $ echo "Marra et al. 2014" > references.txt
  
  # Stage and commit:
  $ git add references.txt
  $ git commit -m "Fixed the references"
  ```

--

- Now we've made changes to each of the two branches.
  Let's see the log in "graph" format with `--graph`,
  also listing all branches with `--all`:
  ```sh
  $ git log --oneline --graph --all
  ```

---

## CSB 2.6: Branching and merging &ndash; Code-along

- We actually already finished speeding up the code,
  but need to document our changes,
  so we go back to the `fastercode` branch:
  ```sh
  $ git checkout fastercode
  
  $ echo "# My documentation" >> code.txt
  $ git add code.txt
  $ git commit -m "Added comments to the code"
  ```

- Again we check the log graph:  
  ```sh
  $ git log --oneline --all --graph
  ```

---

## CSB 2.6: Branching and merging &ndash; Code-along

- We are happy with the changes to the code, and want to make the `fastercode`
  version the default version.
  
  This means we should merge the `fastercode` branch back into `master`.
  To do so, we first have to move back to master:
  ```sh
  $ git checkout master
  ```

- Now we are ready to merge, and we use the `git merge` command.
  We also provide a commit message, because a merge is always accompanied
  by a commit:
  ```sh
  $ git merge fastercode -m "Much faster version of code"
  ```

- *Again* we check the log graph:  
  ```sh
  $ git log --oneline --all --graph
  ```

---

## CSB 2.6: Branching and merging &ndash; Code-along

- We no longer need the `fastercode` branch, so we can delete it:
  ```sh
  git branch -d fastercode
  ```

- Again we check the log graph:
  ```sh
  git log --oneline --all --graph
  ```

---

## CSB 2.6: Branching and merging &ndash; Workflow summary

<figure>
<p align="center">
<img src="img/csb-branch.png" width="100%">
<figcaption>Figure from Allesino & Wilmes (2019)</figcaption>
</p>
</figure>

---

## CSB 2.6: Branching and merging &ndash; Workflow summary

```sh
# Create a new branch:
$ git branch mybranch

# Move to new branch:
$ git checkout mybranch

# Add and commit changes:
$ git add --all
$ git commit -m "my message"

# Done with branch -- move back to main trunk and merge
$ git checkout master
$ git merge mybranch -m "message for merge"

# And [optionally] delete the branch:
$ git -d mybranch
```

---

## `r icon::fa("user-edit")` Intermezzo 2.2

**(a)** Move to the directory `CSB/git/sandbox`.

**(b)** Create a directory `thesis` and turn it into a Git repository.

**(c)** Create the file `introduction.txt` with the line *"The best introduction
ever."*

**(d)** Stage `introduction.txt` and commit with the message *"Started introduction."*

**(e)** Create the branch `newintro` and change into it.

**(f)** Change (overwrite) the contents of `introduction.txt`, create a new file  `methods.txt`, and commit.

**(g)** Look at the commit history of the branches.

**(h)** Change to the branch `master`, merge, and confirm that the changes you
performed within the branch `newintro` are now also part of the branch
`master`.

**(i)** Delete the branch `newintro`.

---

## `r icon::fa("user-edit")` Intermezzo 2.2: Solutions

**(a)** Move to the directory `CSB/git/sandbox`:

```sh
$ cd ∼/CSB/git/sandbox
```

**(b)** Create a directory `thesis` and turn it into a Git repository:

```sh
$ mkdir thesis
$ cd thesis
$ git init
```

**(c)** Create the file `introduction.txt`:
```sh
$ echo "The best introduction ever" > introduction.txt
```

**(d)** Stage and commit `introduction.txt`:
```sh
$ git add introduction.txt
$ git commit -m "Started introduction"
```

---

## `r icon::fa("user-edit")` Intermezzo 2.2: Solutions (cont.)

**(e)** Create the branch `newintro` and change into it:
```sh
$ git branch newintro
$ git checkout newintro
```

**(f)** Change the contents of `introduction.txt`, create a new file  `methods.txt`, and commit:
```sh
$ echo "A much better introduction" > introduction.txt
$ touch methods.txt
$ git add --all
$ git commit -m "A new introduction and methods file"
```

**(g)** Look at the commit history of the branches:
```sh
$ git log --oneline
```

---

## `r icon::fa("user-edit")` Intermezzo 2.2: Solutions (cont.)

**(h)** Change to the branch `master`, merge, and confirm that the `newintro`
changes are in `master`:
```sh
$ git checkout master
$ git merge newintro
$ ls
$ cat introduction.txt
```

**(i)** Delete the branch `newintro`:
```sh
$ git branch -d newintro
$ git log --oneline
```

---
class:inverse middle center

# CSB 2.7

----

# Contributing to public repositories

<br> <br> <br>

---

## CSB 2.7: What can you do with <br> someone else's GitHub repository?

If you do not have rights to *push*, you can:
  
  - **Clone** the repo and make changes locally (as we do with `CSB`).
  
  - **Fork** the repository and develop it independently (!)
  
  - Submit a **pull request** [**(bonus slides)**](#pull-request)
    with proposed changes to the repo,  
    if you want to contribute to the original project.

--

<br>
.content-box-info[
If it's a project your collaborating on, you should ask your collaborator
to give you admin rights for the repo.
]

---
class:inverse middle center

# In closing: Some best practices for Git

----

<br> <br> <br> <br> <br>

---

## Some best practices for Git

- **Write informative commit messages.**  
  Imagine looking back at your project
  in a few months, after finding an error that you introduced a while ago.

  - **Bad:** "Updated file"
  - **Good:** "Updated x function to include y"

--

- **Commit often, using small commits.**  
  This will also help to keep commit messages informative!

- **Before committing, check what you've changed.**  
  Use `git diff [--staged]` or VS Code functionality.

.content-box-info[
Separate commits if your working dir contains work from disparate edits:
use `git add` + `git commit` separately for two sets of files.
]

--

- **When collaborating: pull often.**  
  This will reduce the chances of merge conflicts.

- **Don't commit unnecessary files.**  
  These can also lead to conflicts.

---
class: inverse middle center

# Questions?

----

<br> <br> <br> <br>

---
class: inverse middle center

# Bonus Materials

----

<br>

.left[
- ### [git stash](#stash)
- ### [Resolving merge conflicts](#merge-conflict)
- ### [Forking and creating a Pull Request](#pr)
]

<br> <br>


---
background-color: #f2f5eb
name: stash

## `git stash`

Git stash can be useful when you need to pull from remote,
but have changes in your working dir that:
  - Are not appropriate for a separate commit
  - Are not worth starting a new branch for because you want to get these
    changes back on the current branch immediately.

<br>

```sh
# Stash changes to tracked files:
$ git stash    # Note: add option -u to include untracked files

# Pull from the remote repository:
$ git pull

# Apply stashed changes:
$ git stash apply
```

---
background-color: #f2f5eb
name: merge-conflict

## CSB 2.6: Resolving merge conflicts

```sh
$ code <conflicting-file> # Show features!
```

## TODO

---
background-color: #f2f5eb
name: pr

## CSB 2.7: Forking and creating a Pull Request

## TODO

- Show forking and how this is displayed in the forked repo.
  - Make a change
  - Will say "1 commit ahead" -> Click `Compare`
  - `Create Pull Request`
