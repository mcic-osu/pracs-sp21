<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Week 4 - Unix Data Tools - I</title>
    <meta charset="utf-8" />
    <script src="libs/header-attrs/header-attrs.js"></script>
    <link href="libs/remark-css/default.css" rel="stylesheet" />
    <link href="libs/remark-css/default-fonts.css" rel="stylesheet" />
    <link href="libs/font-awesome/css/fontawesome-all.min.css" rel="stylesheet" />
    <link rel="stylesheet" href="slides.css" type="text/css" />
    <link rel="stylesheet" href="slides_copy.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">

class:inverse middle center



## *Week 4: Unix Data Tools*

----

# Part II: &lt;br&gt; awk and sed

&lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt;

### Jelmer Poelstra
### 2021/02/02 (updated: 2021-01-30)

---

## `awk`

- `awk` is a small programming language in itself!  

- `awk` is great for *quick file processing*, especially on tabular data.

  It is not (necessarily) the best choice for complicated tasks &amp;ndash;  
  perhaps best used as a very powerful tool rather than
  a stand-alone programming language.

&lt;br&gt;

To understand `awk`, we should cover its two core concepts:
  
  - **Record processing**
  
  - **Pattern-action pairs**

---

## `awk` record processing: Records and fields

- "Records":
  
  - `awk` processes *records* one at a time, like a `for` loop going line by line.  

  - By default, **each line is one _record_**.
  
  - The entire record is assigned to `$0`.

- "Fields":
  
  - Within a line, **each column is a _field_**.
  
  - Columns are automatically assigned to `$1`, `$2`, `$3`, etc. 

&lt;br&gt;

```sh
$ awk '{ print $0 }' my.txt           # $0: full line

$ awk '{ print $3 "\t" $2 }' my.txt   # $3 &amp; $2: 3rd and 2nd column
```

---

## `awk` record processing: Pattern-action pairs

- **Pattern**: an expression or regex pattern &amp;ndash; a *condition* to be tested.

- **Action**: If the pattern evaluates to true, the action is performed.

.content-box-blue[
General syntax: **`awk 'pattern { action }' file`**

Note also that the `awk` command is placed *between single quotes*.
]

--

&lt;br&gt;

- Only one of the two (action and pattern) is required:

  - Omit the pattern: action is performed for *every record*.
  ```sh
  $ awk '{ print $0 }' my.txt   # Pattern omitted
  ```
  
  - Omit the action: print all records that match the pattern.
  ```sh
  $ awk '$3 &lt; 10' my.txt        # Action omitted
  ```
  
---

## Simple `awk` examples: action only

**First, we omit patterns, so all lines (records) are subjected
to the action:**

- If we then print the entire record with `print $0`,  
  we mimic `cat` &amp;mdash; each line will be printed in its entirety.
  ```sh
  $ awk '{ print $0 }' example.bed
  ```

&lt;br&gt;

--

- We can also mimic `cut` &amp;ndash; and here we go beyond `cut` to reorder columns:
  ```sh
  $ awk '{ print $3 "\t" $2 }' example.bed  # Cf. Buffalo example
  
  # What happes without "\t"?
  $ awk '{ print $3 $2 }' example.bed       # Columns concatenated
  $ awk '{ print $3,$2 }' example.bed       # Default sep: " "
  ```

---

## Simple `awk` examples: pattern (condition) only

**Now, we use patterns and omit the action: all matching lines are printed.**
  
- Print only lines where column 2 (start of BED feature) is larger than 30:
   ```sh
  $ awk '$2 &gt; 30' example.bed
  ```
  
- Calculate the length of each BED feature (column 3 - column 2),  
  and only print lines in which the feature is at least 18 bp long:
  ```sh
  $ awk '$3 - $2 &gt; 18' example.bed
  ```

--

- Print only lines from "chr1" &amp;ndash; exact match for first column:
  ```sh
  $ awk '$1 == "chr1"' example.bed # Quote the string
  ```
  
- Regular expression patterns are placed between forward slashes:
  ```sh
  $ awk '$1 ~ /chr1/' example.bed # Looks for match in column 1
  $ awk '/chr1/' example.bed  # Looks for match anywhere on line
  ```

---

## `awk` comparison and logical operators

| Comparison  | Description
|-------------|-------------|
| `a == b`    | `a` is equal to `b`
| `a != b`    | `a` is not equal to `b`
| `a &lt; b`     | `a` is less than `b`
| `a &gt; b`     | `a` is greater than `b`
| `a &lt;= b`    | `a` is less than or equal to `b`
| `a &gt;= b`    | `a` is greater than or equal to `b`

---

## `awk` comparison and logical operators

| Comparison  | Description
|-------------|-------------|
| `a == b`    | `a` is equal to `b`
| `a != b`    | `a` is not equal to `b`
| `a &lt; b`     | `a` is less than `b`
| `a &gt; b`     | `a` is greater than `b`
| `a &lt;= b`    | `a` is less than or equal to `b`
| `a &gt;= b`    | `a` is greater than or equal to `b`
| `a ~ /b/`   | `a` matches regular expression pattern `b`
| `a !~ /b/`  | `a` does not match regular expression pattern `b`
| `a &amp;&amp; b`    | logical and: `a` **and** `b`
| `a` &lt;code&gt;&amp;#124;&lt;/code&gt;&lt;code&gt;&amp;#124;&lt;/code&gt; `b` | logical or: `a` **or** `b` *[note typo in Buffalo]*
| `!a`        | not a (logical negation)

---

## <i class="fas  fa-user-edit "></i> `awk` mini-practice

1. Use a pattern (condition) to only print features (= rows) in `example.bed`
   which end at position 28.

2. Use an action to print, for each row, the chromosome and the length of
   the feature (column 3 - column 2).

3. Combine the action from 1. with the pattern (condition) from 2.

---

## <i class="fas  fa-user-edit "></i> `awk` mini-practice: solutions

1. Use a pattern (condition) to only print features (= rows) in `example.bed`
   which end at position 28.
  ```sh
  $ awk '$3 == 28' example.bed
  ```

2. Use an action to print, for each row, the chromosome and the length of
   the feature (column 3 - column 2).
  ```sh
  $ awk '{ print $1, $3-$2 }' example.bed
  $ awk '{ print $1 "\t" $3-$2 }' example.bed # Alt: tab-delimited
  ```

3. Combine the action from 1. with the pattern (condition) from 2.
  ```sh
  $ awk '$3 == 28 { print $1, $3-$2 }' example.bed
  ```

---

## `awk`: Filtering and combining expressions

- Combining patterns &amp;ndash; print *chr1* features longer than 10 bp:

  ```sh
  $ awk '$1 ~ /chr1/ &amp;&amp; $3 - $2 &gt; 10' example.bed
  ```

- Select *chr2* and *chr3* and add a column that contains feature length: 
  ```sh
  $ awk '$1 ~ /chr2|chr3/ { print $0 "\t" $3 - $2 }' example.bed
  ```

--

.content-box-info[
**'|'** can be used directly: `awk` uses *extended regex* (ERE).
]

.content-box-info[
We can use **`|`** *within* a regex,  
and **`||`** and **`&amp;&amp;`** to chain together multiple regex.

```sh
$ awk '/chr1|chr2/' example.bed

$ awk '/chr1/ || /chr2/' example.bed
```
]
  
---

## `awk` so far

&gt; *So far, these exercises have illustrated two ways Awk can come in handy:*
&gt; - *For filtering data using rules that can combine regular expressions and arithmetic*
&gt; - *Reformatting the columns of data using arithmetic*

---

## `awk`: Actions before and after record processing

- The `BEGIN` and `END` patterns can be used to specify actions before and
  after record processing. Here:
  
    - We initialize a variable `s` before starting record processing;
    
    - For each record, add the sum of the feature length (col3 - col2) to `s`;
    
    - After record processing, calculate the mean by dividing by `NR`,  
      the number of records.
  
  ```sh
  $ awk 'BEGIN{ s = 0 };            
      { s += ($3-$2) };             
      END{ print "mean: " s/NR };' example.bed
  ```

--

.content-box-info[
The `+=` operator is shorthand for adding to a variable:
`x += 1` means `x = x + 1`. It is used in many languages including Python.
] 

.content-box-info[
When using multiple pattern-action pairs, separate them with "**`;`**".
]
---

## `awk` special variables and keywords

| keyword/&lt;br&gt;variable  | meaning    |
|----------|------------|
| `BEGIN`  | Used as a pattern that matches the start of the file
| `END`    | Used as a pattern that matches the end of the file
| `NR`     | Number of Records (running count; in `END`: total nr. of lines)
| `NF`     | Number of Fields (for each record)
| `$0`     | Contains entire record (usually a line)
| `$1` - `$n` | Contains one column each

---

## `awk` special variables and keywords

| keyword/&lt;br&gt;variable  | meaning    |
|----------|------------|
| `BEGIN`  | Used as a pattern that matches the start of the file
| `END`    | Used as a pattern that matches the end of the file [cf. `EOF`]
| `NR`     | Number of Records (running count; in `END`: total nr. of lines)
| `NF`     | Number of Fields (for each record)
| `$0`     | Contains entire record (usually a line)
| `$1` - `$n` | Contains one column each
| `FS`     | Input Field Separator (default: any whitespace)
| `OFS`    | Output Field Separator (default: single space)
| `RS`     | Input Record Separator (default: newline)
| `ORS`    | Output Record Separator (default: newline)

---

## `awk` functions

| Function         | Meaning                        |
|------------------|--------------------------------|
| `length(&lt;string&gt;)`        | Return number of characters
| `tolower(&lt;string&gt;)`       | Convert to lowercase
| `toupper(&lt;string&gt;)`       | Convert to uppercase
| `substr(&lt;string&gt;, &lt;start&gt;, &lt;end&gt;)`  | Return substring
| `split(&lt;string&gt;, &lt;array&gt;, &lt;delimiter&gt;)`   | Split into chunks in an array
| `sub(&lt;from&gt;, &lt;to&gt;, &lt;string&gt;)`        | Substitute (replace) regex
| `gsub(&lt;from&gt;, &lt;to&gt; &lt;string&gt;)`        | &gt;1 substitution per line 
| print                     | Print, e.g. column: `print $1`
| exit                      | Break out of record-processing loop; e.g. to stop when match is found
| next                      | Don't process later fields: to next iteration
| 

---

## Counting columns with `awk`

- `NF` is the number of *fields*. This finally brings us to the
  column-counting example shown earlier in the Buffalo chapter:
  ```sh
  $ mus=Mus_musculus.GRCm38.75_chr1
  
  $ awk -F "\t" '{print NF; exit}' "$mus".bed
  ```
  
  .content-box-red[
  <i class="fas  fa-question "></i> &amp;nbsp; Why do we need the `exit` function here?
  ]

&lt;br&gt;

--

- For the **GTF** file, we need to omit the header lines (starting with a `#`)
  before we can count columns, which we can with `grep` or `awk` itself:
  ```sh
  $ grep -v "^#" "$mus".gtf | awk -F "\t" '{print NF; exit}'
  
  $ awk -F "\t" '!/^#/ {print NF; exit}' "$mus".gtf
  ```

---

## Miscellaneous `awk`

- We can also use `NR` to print specific lines (here, 3-5):
  ```sh
  $ awk 'NR &gt;= 3 &amp;&amp; NR &lt;= 5' example.bed
  ```

- We can convert a GTF file to a BED file (subtracting 1 from the end position):
  ```sh
  $ awk '!/^#/ { print $1 "\t" $4-1 "\t" `\(5 }' "\)`mus".gtf | \
        head -n 3
  ```

--

.content-box-info[
We'll skip the final example, which uses an "associative array"
(= "dictionary" in Python) and a `for` loop within `awk` &amp;ndash;
this level of complexity is where switching to Python/R often makes sense.  
But have a look if you like `awk`!
]

.content-box-info[
If you work a lot with sequencing data, check out the `bioawk` section.
]

---

## Replacing strings with `sed`

- `sed` is most often used to perform string replacements,  
  using the syntax `'s/pattern/replacement/[modifiers]'`,  
  where `s` stands for **substitute**.
  
  For instance, we can replace "chrom" by "chr" like so:

  ```sh
  $ head -n 3 chroms.txt # before sed
  #&gt; chrom1  3214482 3216968
  #&gt; ...
  
  $ sed 's/chrom/chr/' chroms.txt | head -n 3
  #&gt; chr1  3214482 3216968
  #&gt; ...
  ```

--

&lt;br&gt;

- For **global substitution** (&gt;1 per line), we use the **`g`** modifier,  
  and for **case-insensitive** matching, the **`i`** modifier:
  
  ```sh
  $ sed 's/chrom/chr/ig' chroms.txt | head -n 3
  ```

---

## `sed` output options

- Note that `sed` does not edit the file in place, and outputs to standard out.
  Usually, we redirect the output to a new file:
  ```sh
  $ sed 's/chrom/chr/ig' chroms.txt &gt; chroms_renamed.txt
  ```

- When we want replacements in place, **don't redirect to the same file!**
  
  ```sh
  $ sed 's/chrom/chr/ig' chroms.txt &gt; chroms.txt # NO!!
  ```
  
  .content-box-red[
  <i class="fas  fa-question "></i> &amp;nbsp; Why does this fail?
  ]

--

- But we can instruct `sed` to perform the replacement **in place** like so:

  ```sh
  $ cp chroms.txt chroms_inplace.txt
  $ sed -i 's/chrom/chr/' chroms_inplace.txt # Edits file!
  
  # Or create a backup copy using "inplace=&lt;backup-suffix&gt;"
  $ cp chroms.txt chroms_inplace2.txt
  $ sed --inplace=backup 's/chrom/chr/' chroms_inplace2.txt
  ```

---

## Reformatting using `sed`

- Let's say we want to replace the format `chr1:28427874-28425431`
  ("chrom:start-end") by having a tab (`"\t"`) between each field.  
  
  We would normally do this using input from a file,  
  but we can nicely try things out with input piped from `echo`:
  ```sh
  # Use two consecutive sed calls:
  $ echo "chr1:28427874-28425431" | sed 's/:/\t/' | sed 's/-/\t/'
  
  # Use -e for multiple expressions:
  $ echo "chr1:28427874-28425431" | sed -e 's/:/\t/' -e 's/-/\t/'
  
  # Use a character class to match both the : and - at once:
  $ echo "chr1:28427874-28425431" | sed 's/[:-]/\t/g'
  ```

--

.content-box-info[
Note that `tr` would also work for this task:
```sh
$ echo "chr1:28427874-28425431" | tr ':-' '\t'
```
]

---

## <i class="fas  fa-user-edit "></i> `sed` mini-practice

In `Mus_musculus.GRCm38.75_chr1_genes.txt`:

1. The geneIDs were for the wrong organism: replace `ENSMUS` by `GALGAL`.
   (Don't write to a new file, but check your result by piping into `head`.)
   
2. Replace the tabs by an underscore.
   (Don't write to a new file, but check your result by piping into `head`.)
   
3. Do both at the same time, and write to a new file `genes_fixed.txt`.

---


## Backreferences in regular expressions

Let's say our start and end columns are reversed.
In `awk`, fields-as-variables (`$1`, etc.) makes reordering easy.
How can we do this with `sed`?

- We can use **backreferences**, which allow you to capture a matched string,
  and *recall it*.
  (A general regex feature: we will see this in Python.)

- Backreferences are *captured* in parentheses:  **`(pattern1)-(pattern2)`**,
  and *recalled* using **`\1`** for the first one
  **`\2`** for the second one, etc.

--

- For instance, in `sed`, to invert the order of two words:

  ```sh
  $ echo "inverted words" | sed -E 's/(\w+) (\w+)/\2 \1/'
  # words inverted
  ```

- Recalling a backreference can also happen while matching!

  ```sh
  echo "abab" | grep -E '(ab)\1'
  # abab
  ```

--

  .content-box-info[
  For `grep` &amp; `sed`, don't forget to turn on extended regex with **`-E`**!
  ]

---

## Reformatting using `sed` (cont.)

- So, let's invert these two fields:
  ```sh
  $ echo "28425431-28427874" | sed -E 's/([0-9]+)-([0-9]+)/\2-\1/'
  #&gt; 28427874-28425431
  ```
  
- Going back to the format that has `chr` as well:  
  ```sh
  $ echo "chr1:28425431-28427874" | \
      sed -E 's/(chr[0-9]+):([0-9]+)-([0-9]+)/\1:\3-\2/'
  #&gt; 28427874-28425431
  ```

- What if *some* chromosomes had names like `chr9a`?  
  To allow for any character up until the delimiter (**`:`**),  
  we could use **`:`** as a character class and *negate* it:
  ```sh
  $ echo "chr9a:28425431-28427874" | \
      sed -E 's/(chr[^:]+):([0-9]+)-([0-9]+)/\1:\3-\2/'
  #&gt; 28427874-28425431
  ```

---

## Reformatting using `sed` (cont.)

- Finally, we can reformat the output. Here is the example from Buffalo,
  which gives tab-separated (**`\t`**) output:
  
  ```sh
  $ echo "chr1:28427874-28425431" | \
      sed -E 's/^(chr[^:]+):([0-9]+)-([0-9]+)/\1\t\2\t\3/'
  ```
  
  &lt;br&gt;
  
  .content-box-info[
  Note the caret sign **`^`** in **`s/^`**,
  which matches the beginning of a line.
  
  Not to be confused with a **`^`** as the first character inside **`[]`**,
  which is used for negation (!).
  
  The counterpart of **`^`** is **`$`**,
  which matches the end of a line.
  ]

---

## Print only matching or selected lines using `sed`

- Let's say we want to **extract a list of transcript IDs** from a GTF file,  
  which are formatted as `"transcript_id "ENSMUST00000160944"`.

  ```sh
  $ grep -v "^#" "$mus".gtf | head -n 3 | \
        sed -E 's/.*transcript_id "([^"]+)".*/\1/'
  ```
  
--
  
  .content-box-q[
  What went wrong?
  ]
  
--
  
  .content-box-answer[
  By default, non-matching lines are also printed &amp;ndash;  
  and for those lines, there was no replacement to be made,  
  and they were printed in full.
  ]
  
---

## Print only matching or selected lines using `sed`

- We can tell `sed` to only print matching lines using the **`-n`** option,
  which turns off printing lines, and then using the **`p`** modifier for matches,
  to print those lines:
  ```sh
  # Print only lines containing the pattern 'abc' (mimics grep!): 
  $ sed -n '/abc/p' 
  ```

- So let's apply this technique to our GTF file:
  ```sh
  $ grep -v "^#" "$mus".gtf | head -n 3 | \
        sed -E -n 's/.*transcript_id "([^"]+)".*/\1/p'
  ```

&lt;br&gt;

- We can also use this construct to simply print specific line numbers:
  ```sh
  $ sed -n '20,50p' "$mus".gtf # Print lines 20-50
  ```

---

## Misc. `sed`

- Note that you can use **other delimiters than `/`** in the substitution command,
  which can be useful when patterns and/or replacement contain slashes:
  
  ```sh
  $ echo "data/fastq/sampleA.fastq" | sed 's#data/fastq/##'
  #&gt; sampleA.fastq
  ```

&lt;br&gt;

.content-box-info[
Almost any character works, but the "rarer" the character, the better.  
]

---

## McIlroy's oneliner

```sh
$ cat file | tr -c A-Za-z '\n' | \
    tr A-Z a-z | \
    sort | \
    uniq -c | \
    sort -rn | \
    sed 10q
```

---
class: inverse middle center

# Questions?

----

&lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt;

---
class: inverse middle center

# Bonus Materials

----

&lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt;

---
background-color: #f2f5eb

---

## Subshells

```sh
$ (zgrep "^#" "$mus".gtf.gz; \
    zgrep -v "^#" "$mus".gtf.gz | sort -k1,1 -k4,4n) | \
    gzip &gt; "$mus"_sorted.gtf.gz
```

---

## A subshell and a custom function

- "Subshell" between ( ): both head and tail get the same standard input:
  
  ```sh
  (head -n 2; tail -n 2) &lt; file
  ```

- Creating a custom function:

  ```sh
  # Note that there was an error in Buffalo's function, lacking a trailing ";"
  i() { (head -n 2; tail -n 2) &lt; "$1" | column -t; }
  ```
  
  - This is a nice trick, but ...
  
  - Mention aliases?

---

## Process substitution

```sh
$ cat &lt;(echo "hello, process substitution")
```

```sh
$ cat $(echo "hello, process substitution")
#&gt; cat: hello,: No such file or directory
#&gt; cat: process: No such file or directory
#&gt; cat: substitution: No such file or directory
```

```sh
$ echo "hello, process substitution" | cat
```

---

## Process substitution (cont.)

- Capturing input streams:
  ```sh
  program --in1 &lt;(makein raw1.txt) --in2 &lt;(makein raw2.txt) \
  --out1 out1.txt --out2 out2.txt
  ```

- Capturing output streams:
  ```sh
  program --in1 in1.txt --in2 in2.txt \
  --out1 &gt;(gzip &gt; out1.txt.gz) --out2 &gt;(gzip &gt; out2.txt.gz)
  ```

- Combining both:
  ```sh
  program --in1 &lt;(makein raw1.txt) --in2 &lt;(makein raw2.txt) \
      --out1 &gt;(gzip &gt; out1.txt.gz) --out2 &gt;(gzip &gt; out2.txt.gz)
  ```

- Why is this useful? Why not write intermediate files?

---
background-color: #f2f5eb

## Greedy and non-greedy matching with regex

- When matching with regular expressions,
  you need to take care to match to "greedily".
  
  For instance, when using a delimiter to try to define the end of the match,
  but this delimited occurs multiple times, problems can occur:
  
  ```sh
  $ echo 'transcript_id "ENSMUST00000160944"; gene_name "Gm16088"' \
        &gt; greedy_example.txt
  
  $ sed -E 's/transcript_id "(.*)".*/\1/' greedy_example.txt
  # ENSMUST00000160944"; gene_name "Gm16088
  ```
  
- Instead, ...

  ```sh
  $ sed -E 's/transcript_id "([^"]+)".*/\1/' greedy_example.txt
  # ENSMUST00000160944
  ```

---
background-color: #f2f5eb

## Optional install for Mac users: &lt;br&gt; `GNU` instead of `BDS` tools

Assumes you have already installed Homebrew &amp;mdash;
if not, go back to the optional installation instructions in Week 1.

```sh
brew install coreutils # Basic tools like ls, cat, head, tail etc.
brew install grep      # To get GNU grep, not included in basic tools
brew install gnu-sed   # To get GNU sed, also not included in basic
```

- After this, use `gcat` instead of `cat`, `ggrep` instead of `grep` etc.

- To check your installation, e.g.:
  ```sh
  ggrep --version
  ```
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "rainbow",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
