<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Week 6 - Shell scripting - I</title>
    <meta charset="utf-8" />
    <script src="libs/header-attrs/header-attrs.js"></script>
    <link href="libs/remark-css/default.css" rel="stylesheet" />
    <link href="libs/remark-css/default-fonts.css" rel="stylesheet" />
    <link rel="stylesheet" href="slides.css" type="text/css" />
    <link rel="stylesheet" href="slides_copy.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">

class:inverse middle center



## *Week 6: Shell scripting*

----

# Part I: &lt;br&gt; Setting the stage for scripting: &lt;br&gt; Variables, loops, arrays, and conditionals

&lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt;

### Jelmer Poelstra
### 2021/02/15 (updated: 2021-02-05)

---

## Setting up

- Start VS Code in OSC OnDemand =&gt; open your workspace =&gt;
  open a terminal =&gt; type `bash` to break out of the Singularity shell. 

- Move into the Chapter 12 directory in your copy of the Buffalo Git repository,
  likely at:
  ```sh
  $ cd /fs/ess/PAS1855/users/$USER/bds-files/chapter-12-pipelines
  
  # Lost the repo? Go to your directory and run:
  # git clone https://github.com/vsbuffalo/bds-files.git
  ```

---
class: inverse middle center

# Overview

----

.left[
- ### [Variables (and quoting)](#variables)
- ### [For loops](#for)
- ### [While loops (and the read command)](#while)
- ### [Bash arrays (and field splitting)](#arrays)
- ### [Conditionals](#conditionals)
- ### [basename](#basename)
]

&lt;br&gt;

---
class: inverse middle center
name: variables

# Variables (and quoting)

----

&lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt;

---

## Variables

&gt; *"Processing pipelines having numerous settings that should be stored in variables
(e.g., which directories to store results in, parameter values for commands,
input files, etc.).
Storing these settings in a variable defined at the top of the file makes adjusting
settings and rerunning your pipelines much easier. Rather than having to change
numerous hardcoded values in your scripts, using variables to store settings means
you only have to change one value—the value you’ve assigned to the variable."*
&amp;mdash; Buffalo ch. 12

&lt;br&gt;

--

.content-box-info[
Side note: An even better solution than variables at the top of a file
is to put these in configuration files (=&gt; Snakemake week) &amp;mdash;  
but you'll be using variables in any case.
]

- Similarly, variables are useful to be able to pass arguments to a
  script, so you can easily rerun a script with a different input file.

---

## Assigning and using shell variables

A variable is nothing more than a *pointer to the actual data*.

.pull-left[
**Assign** a variable (no **`$`**):

```sh
# Any string:
my_name=Jelmer
```
]

.pull-right[
**Recall** a variable (with **`$`**):

```sh
$ echo $my_name
# Jelmer
  ```
]

--

.pull-left[
```sh
# A file name:
my_file="README.txt"
```
]

.pull-right[
```sh
$ ls -lh $my_file
# -rw-r--r-- 1 jelmer PAS0471 568 Dec  7 09:58 README.txt
```
]

--

.pull-left[  
```sh
# Use "command substitution"
# to assign a command's output
today=$(date +%F)
```
]

.pull-right[
```sh
$ touch README_$today.txt
$ ls README_*
# README_2020-12-10.txt
```
]

--

.pull-left[
Pre-existing variables:
("**Environment variables**")
]

.pull-right[
```sh
$ echo $USER
# jelmer
```
]

---

## Quoting variables

- What happens if the value of our variable contains spaces?

  ```sh
  $ today="Thu, Feb 8"
  $ echo $today
  
  $ touch README_$today.txt
  $ ls
  #&gt; .txt  Feb  README_Thu,
  ```

- Oops! The shell performed **field splitting** to split the value into three
  separate units, and as a result, three non-sensical files were created.

  This can be avoided by **quoting the variable**:
  
  ```sh
  $ touch README_"$today".txt
  $ ls
  #&gt; 'README_Thu, Feb 8.txt'
  ```

---

## Quoting variables (cont.)

- Without quoting, we can't explicitly say where our variable name ends:

  ```sh
  $ touch README_$today_final.txt
  #&gt; README_.txt
  
  $ day_partial=Thu
  $ day_full=$day_partialrsday
  $ echo $day_full
  #&gt; 
  ```

- Quoting solves this, too:

  ```sh
  $ touch README_"$today"_final.txt
  #&gt; 'README_Thu, Feb 8_final.txt'
  
  $ day_full="$day_partial"rsday
  $ echo $day_full
  #&gt; Thursday
  ```

.content-box-info[
For these two reasons, it is good practice to always quote your variables
&amp;ndash; certainly in scripts where you can't babysit your code.
]

---

## Quoting variables (cont.)

.content-box-info[

Putting variable names between curly braces will also make it clear where the
variable name begins and ends, but it does not prevent field splitting:

```sh
$ touch README_${today}_final.txt
#&gt; 8_final.txt .txt  Feb  README_Thu,
```

Finally, you can combine curly braces and quoting:
```sh
$ touch README_"${today}"_final.txt
#&gt; 'README_Thu, Feb 8_final.txt'
```
]

---
class: inverse middle center
name: for

# For loops

----

&lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt;

---

## For loops

```sh
$ for mushroom in morel destroying_angel eyelash_cup; do
      echo "$mushroom is an Ohio mushroom"
  done
#&gt; morel is an Ohio mushroom
#&gt; destroying_angel is an Ohio mushroom
#&gt; eyelash_cup is an Ohio mushroom
```

--

```sh
$ for fungus in morel destroying_angel eyelash_cup; do
      echo "$fungus is an Ohio mushroom"
  done
#&gt; morel is an Ohio mushroom
#&gt; destroying_angel is an Ohio mushroom
#&gt; eyelash_cup is an Ohio mushroom
```

---

## For loops

```sh
$ for mushroom in morel destroying_angel eyelash_cup; do
      echo "$mushroom is an Ohio mushroom"
  done
#&gt; morel is an Ohio mushroom
#&gt; destroying_angel is an Ohio mushroom
#&gt; eyelash_cup is an Ohio mushroom
```

.content-box-info[
A semicolon `;` separates two commands written on a single line:
```sh
cd data; ls
```
]

.content-box-info[
Alternative formatting that puts `do` on its own line:
```sh
$ for fungus in morel destroying_angel eyelash_cup
  do
      echo "$fungus is an Ohio mushroom"
  done
```
]

---

## For loops

- To bring home the point that each item is processed one-by-one:
 
  ```sh
  $ loop_counter=0
  
  $ for mushroom in morel destroying_angel eyelash_cup; do
        
        loop_counter=$(expr "$loop_counter" + 1)
        
        echo "$mushroom is Ohio mushroom number $loop_counter"
    done
  
  #&gt; morel is Ohio mushroom number 1
  #&gt; destroying_angel is Ohio mushroom number 2
  #&gt; eyelash_cup is Ohio mushroom number 3
  ```

---

## For loops (cont.)

- In practice, we rarely enumerate by hand the items we want to loop over.
  
- Instead, we commonly loop over files using globbing: 

  ```sh
  $ for fastq_file in data/raw/*fastq.gz; do
        
        echo "File $fastq_file has $(wc -l &lt; $fastq_file) lines."
        # Further processing...
    done
  ```

- Or perhaps over some predefined sequence like so:

  ```sh
  $ seq 1 100
  #&gt; 1
  #&gt; 2
  #&gt; ...
  
  $ for i in $(seq 1 100); do
        
        echo "Run $i out of 100"
        # Further processing...
    done
  ```

---

## For loops (cont.)

- We can also loop over items in an *array*:  
  (like a vector in R, or a list in Python)

  ```sh
  $ for sample_name in "${sample_names[@]}"; do
        
        echo "Processing sample $sample_name"
        input_file="$sample_name"_R1.fastq
        
        # Further processing...
    done
  ```

.content-box-info[
**Creating an array:**

```sh
# Manually define the array:
$ sample_names=(zmaysA zmaysB zmaysC)

# Save a column from a file in an array:
$ sample_names($(cut -f 3 samples.txt))
```
]

---
class: inverse middle center
name: for

# While loops (and the read command)

----

&lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt;

---

## First &amp;ndash; Our metadata files

- The file `samples.txt` is in the Buffalo repo:

  ```sh
  $ cat samples.txt
  #&gt; zmaysA  R1      seq/zmaysA_R1.fastq
  #&gt; zmaysA  R2      seq/zmaysA_R2.fastq
  #&gt; zmaysB  R1      seq/zmaysB_R1.fastq
  #&gt; zmaysB  R2      seq/zmaysB_R2.fastq
  #&gt; zmaysC  R1      seq/zmaysC_R1.fastq
  #&gt; zmaysC  R2      seq/zmaysC_R2.fastq
  ```

- We will also create a file with just the paths to the fastq files,
  by selecting only the third column from `samples.txt`:
  
  ```sh
  $ cut -f 3 samples.txt &gt; fastq_files.txt
  
  $ head -n 3 fastq_files.txt
  #&gt; seq/zmaysA_R1.fastq
  #&gt; seq/zmaysA_R2.fastq
  #&gt; seq/zmaysB_R1.fastq
  ```

---

## While loops

- While loops are similar to for loops,
  but instead of looping over a predefined listing of items,
  **the loop will keep going as long as a condition is true**
  (Infinite loops possible...).
  
  For instance:

  ```sh
  $ i=1
  
  $ while [ $i -lt 10 ]; do  # =&gt; While i is less than 10 
        echo $i
        i=$(expr $i + 1)
    done
  #&gt; 1
  #&gt; 2
  #&gt; 3
  #&gt; 4
  #&gt; 5
  #&gt; 6
  #&gt; 7
  #&gt; 8
  #&gt; 9
  ```

---

## While loops (cont.)

In bash, while loops are mostly useful to loop over each line in a file,
together with the `read` command.

`while read` will be true as long as there is a line to be read,
and upon each iteration of the loop, one line will be saved in the variable:

```sh
$ cat fastq_files.txt | while read -r fastq_file; do
      
      echo "Processing file: $fastq_file"
      
      # Further processing...
  done
  
#&gt; Processing file: seq/zmaysA_R1.fastq
#&gt; Processing file: seq/zmaysA_R2.fastq
#&gt; Processing file: seq/zmaysB_R1.fastq
```

---

## While loops (cont.)

A more elegant but perhaps initially confusing syntax variant:

```sh
$ while read -r fastq_file; do
  
      echo "Processing file: $fastq_file"
  
      # Further processing...
  done &lt; fastq_files.txt

#&gt; Processing file: seq/zmaysA_R1.fastq
#&gt; Processing file: seq/zmaysA_R2.fastq
#&gt; Processing file: seq/zmaysB_R1.fastq
```

---

## While loops (cont.)

```sh
$ head -n 2 samples.txt
#&gt; zmaysA  R1      seq/zmaysA_R1.fastq
#&gt; zmaysA  R2      seq/zmaysA_R2.fastq
```

```sh
while read -r my_line; do
  
  echo "Have read line: $my_line"
  
  fastq_file=$(echo "$my_line" | cut -f 3)
  echo -e "Processing file: $fastq_file \n"
  
  # Further processing...

done &lt; samples.txt

#&gt; Have read line: zmaysA  R1      seq/zmaysA_R1.fastq
#&gt; Processing file: seq/zmaysA_R1.fastq
#&gt;
#&gt; Have read line: zmaysA  R2      seq/zmaysA_R2.fastq
#&gt; Processing file: seq/zmaysA_R2.fastq
#&gt;
```

---

## While loops (cont.)

```sh
$ head -n 2 samples.txt
#&gt; zmaysA  R1      seq/zmaysA_R1.fastq
#&gt; zmaysA  R2      seq/zmaysA_R2.fastq
```

- We can even extract columns directly!

```sh
$ while read -r sample_name readpair_member fastq_file; do
      
      echo "Processing file: $fastq_file"
      
      # Further processing...
  done &lt; metadata.txt

#&gt; Processing file: seq/zmaysA_R1.fastq
#&gt; Processing file: seq/zmaysA_R2.fastq
#&gt; Processing file: seq/zmaysB_R1.fastq
```

---
class: inverse middle center
name: arrays

# Bash arrays and field splitting

----

&lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt;

---

## Bash arrays

Bash arrays are like lists in Python or vectors in R.

- Create an array manually:

  ```sh
  $ sample_names=(zmaysA zmaysB zmaysC)
  ```

- Extract specific elements (note: Bash arrays are 0-indexed!):

  ```sh
  $ echo ${sample_names[0]}
  #&gt; zmaysA
  $ echo ${sample_names[2]}
  #&gt; zmaysC
  ```

- Print all elements:

  ```sh
  $ echo ${sample_names[@]}
  #&gt; zmaysA zmaysB zmaysC
  ```

---

## Bash arrays (cont.)

- Get a count of the number of elements, and element indices:
  ```sh
  echo ${#sample_names[@]}
  #&gt; 3
  
  $ echo ${!sample_names[@]}
  #&gt; 0 1 2
  ```

&lt;br&gt;

- Create an array using command substitution:

  ```sh
  $ sample_files=($(cut -f 3 samples.txt))
  
  $ sample_files=($(cat sample_names.txt))
  ```

---

## Arrays and filenames with spaces

```sh
$ all_files=($(cat files.txt))

$ for file in "${all_files[@]}"; do
      echo $file
  done
#&gt; file_A
#&gt; file_B
#&gt; file_C
#&gt; file
#&gt; D
```

---

## Accounting for problematic filenames with `IFS`

- Setting the Internal Field Separator (`IFS`), which is responsible for
  how the splitting, like above, is done, can solve this...
  ```sh
  $ OFS="$IFS"  # Store original field separator to restore later
  $ IFS="\n"    # Set new IFS to ONLY newlines
  
  $ all_files=($(cat files.txt))
  
  $ for file in "${all_files[@]}"; do
        echo $file
      done
  #&gt; file_A
  #&gt; file_B
  #&gt; file_C
  #&gt; file D
  
  $ IFS="$OFS"  # Restore original IFS
  ```

---

## Other solutions to account for problematic filenames

- Globbing over filenames will work:

  ```sh
  $ ls
  #&gt; file_A file_B file_C file D

  $ for file in file_*; do
        echo $file
      done
  #&gt; file_A
  #&gt; file_B
  #&gt; file_C
  #&gt; file D
  ```

.content-box-warning[
You may be tempted to use `ls` instead: `for file in $(ls file_*)`,
but this will **not** work for filenames with spaces.  
Looping over globbing output is a shorter syntax *and* safer.
]

---

## Other solutions to account for problematic filenames

- `while read` will also work:

  ```sh
  while read -r my_file; do
      
      echo "Processing file: $my_file"
      
      # Further processing...
  done &lt; files.txt
  ```

&lt;br&gt;

.content-box-info[
Moreover, if necessary, you can set the `IFS` more conveniently:

```sh
while IFS="\n" read -r my_file; do ...
```

With this syntax, the shell environment won't be affected elsewhere,
so you don't have to reset the `IFS`.
]

---
class: inverse middle center
name: arrays

# Conditionals

----

&lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt;

---

## Conditionals

```sh
$ if &lt;test&gt;; then
    # Command(s) if condition is true
  else
    # Commands(s) if condition is false
  fi
```

---

## Conditionals

```sh
$ filetype=$(filename | cut -d "." -f 1)
```

```sh
$ if test "$filetype" = "fastq"; then
    
    echo "Processing fastq file..."
    # Commands to process fastq file
  
  else
    
    echo "Unknown filetype!"
  
  fi
```

---

## Conditionals

```sh
$ filetype=$(filename | cut -d "." -f 1)
```


```sh
$ if [ "$filetype" = "fastq" ]; then
    
    echo "Processing fastq file..."
    # Commands to process fastq file
  
  else
    
    echo "Unknown filetype!"
  
  fi
```

--

.content-box-info[
The square brackets represent a *test statement*.  
The spaces around the inside the brackets are necessary:
`["$filetype" = "fastq"]` would fail!
]

---

## Comparison operators (Buffalo Table 12-1)

| String            | Description
|-------------------|----------------
| `-z str`          | String `str` is null (empty)
| `str1 = str2`     | Strings `str1` and `str2` are identical
| `str1 != str2` &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; | Strings `str1` and `str2` are different &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;

| Integer           | Description
|-------------------|----------------
| `int1 -eq int2`   | Integers `int1` and `int2` are equal
| `int1 -ne int2`   | Integers `int1` and `int2` are not equal
| `int1 -lt int2`   | Integer `int1` is less than `int2`
| `int1 -gt int2`   | Integer `int1` is greater than `int2`
| `int1 -le int2`   | Integer `int1` is less than or equal to `int2`
| `int1 -ge int2` &amp;nbsp; &amp;nbsp; &amp;nbsp; | Integer `int1` is greater than or equal to `int2`

--

  .content-box-q[
  Why can we not just use `int1 &gt; int2`, and so on?
  ]

---

## Another example with a comparison operator

```sh
$ n_samples=$(wc -l &lt; samples.txt)

$ if [ "$n_samples" -gt 5 ]; then
    
    # Commands to run if nr of samples &gt;5:
    echo "Processing fastq file..."
  
  else
    
    # Commands to run if nr of samples is not &gt;5:
    echo "Insufficient samples provided..."
  
  fi
```

---

## File and directory test expressions &lt;br&gt; (Buffalo Table 12-2)

| File/dir expression       | Description
|---------------------------|------------
| `-d dir`                  | Dir is a directory
| `-f file`                 | File is a file
| `-e file`                 | File exists
| `-h link`                 | Link is a link
| `-r file`                 | File is readable
| `-w file`                 | File is writable
| `-x file`                 | File is executable &lt;br&gt; (or accessible if argument is expression)

---

## File test example

```sh
$ if [ ! -f "$fastq_file" ]; then
      
      echo "Error: File not found!"
      exit 1
  
  fi
```

---

## Combining expressions (one of several ways)

```sh
if [ "$n_samples" -lt 100 ] &amp;&amp; [ "$n_samples" -ge 50 ]

if [ ! -f "$fastq_file" ] || [ ! -r "$1" ]
```

- The `&amp;&amp;` and `||` are shell operators and can generally be used to chain
  commands together:

```sh
cd data &amp;&amp; ls data

git add --all &amp;&amp; git commit -m "Add README" &amp;&amp; git push

test -d "$outdir" || mkdir "$outdir"

cd "$outdir" || echo "Cannot change directory!"
```

---

## Using the *exit status* of a command as a test

```sh
$ if grep "AAACGT" "$fastq_file" &gt; /dev/nulll; then
    
    # Commands to run if pattern is found:
    echo "Warning: contaminant detected in $fastq_file"
  
  else
  
    # Commands to run if pattern is not found:
    echo "Processing fastq file..."
    
  fi
```

```sh
$ if ! grep "AAACGT" "$fastq_file" &gt; /dev/null; then

    # Commands to run if pattern is not found:
    echo "Processing fastq file..."
    
  fi
```

---
name: basename

## Sidenote to set the stage for scripting: basename

- Running `basename` on a filename will strip any directories in its name:
  
  ```sh
  $ basename seqs/zmaysA_R1.fastq
  #&gt; zmaysA_R1.fastq
  
  $ basename seqs/raw/fastq/zmaysA_R1.fastq
  #&gt; zmaysA_R1.fastq
  ```

--

- You can also provide a *suffix to strip* in either of these ways:

  ```sh
  $ basename seqs/zmaysA_R1.fastq ".fastq"
  #&gt; zmaysA_R1
  
  $ basename -s ".fastq" seqs/zmaysA_R1.fastq
  #&gt; zmaysA_R1
  ```

--

- If you instead want the directory part of the path, use `dirname`:

  ```sh
  $ dirname seqs/zmaysA_R1.fastq
  #&gt; seqs
  ```
  
---
class: inverse middle center

# Questions?

----

&lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt;

---
class: inverse middle center

# Bonus Materials

----

&lt;br&gt;

.left[
- ### [Extended test syntax](#extended-test)
]

&lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt;

---
background-color: #f2f5eb
name: extended-test

## Extended test syntax

```sh
$ [[ ]]
```

    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "rainbow",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
