<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Week 6 - Shell scripting - I</title>
    <meta charset="utf-8" />
    <script src="libs/header-attrs/header-attrs.js"></script>
    <link href="libs/remark-css/default.css" rel="stylesheet" />
    <link href="libs/remark-css/default-fonts.css" rel="stylesheet" />
    <link rel="stylesheet" href="slides.css" type="text/css" />
    <link rel="stylesheet" href="slides_copy.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">

class:inverse middle center



## *Week 6: Shell scripting*

----

# Part I: &lt;br&gt; Loops, arrays, and conditionals

&lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt;

### Jelmer Poelstra
### 2021/02/15 (updated: 2021-02-03)

---
class: inverse middle center

# Overview

----

.left[
- ### [For loops](#for)
- ### [While loops and the read command](#while)
- ### [Bash arrays and field splitting](#arrays)
- ### [Conditionals](#conditionals)
- ### [basename](#basename)
]

&lt;br&gt;

---
class: inverse middle center
name: for

# For loops

----

&lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt;

---

## For loops

```sh
$ for mushroom in morel destroying_angel eyelash_cup; do
      echo "$mushroom is an Ohio mushroom"
  done
#&gt; morel is an Ohio mushroom
#&gt; destroying_angel is an Ohio mushroom
#&gt; eyelash_cup is an Ohio mushroom
```

```sh
$ for fungus in morel destroying_angel eyelash_cup; do
      echo "$fungus is an Ohio mushroom"
  done
#&gt; morel is an Ohio mushroom
#&gt; destroying_angel is an Ohio mushroom
#&gt; eyelash_cup is an Ohio mushroom
```

.content-box-info[
Alternative formatting:
```sh
$ for fungus in morel destroying_angel eyelash_cup
  do
      echo "$fungus is an Ohio mushroom"
  done
```
]

---

## For loops

```sh
loop_counter=0

$ for mushroom in morel destroying_angel eyelash_cup; do
      
      loop_counter=$(expr "$loop_counter" + 1)
      
      echo "$mushroom is Ohio mushroom number $loop_counter"
  done

#&gt; morel is Ohio mushroom number 1
#&gt; destroying_angel is Ohio mushroom number 2
#&gt; eyelash_cup is Ohio mushroom number 3
```

---

## For loops (cont.)

```sh
$ for fastq_file in data/raw/*fastq.gz; do
      
      echo "Fastq file $fastq_file has $(wc -l &lt; $fastq_file) lines"
      
      # Further processing...
  done
```

```sh
$ for i in $(seq 1 100); do
      
      echo "Run $i out of 100"
      
      # Further processing...
  done
```

---

## For loops (cont.)

```sh
sample_names=(zmaysA zmaysB zmaysC)

$ for sample_name in "${sample_names[@]}"; do
      
      echo "Processing sample $sample_name"
      input_file="$sample_name"_R1.fastq
      
      # Further processing...
  done
```

---
class: inverse middle center
name: for

# While loops and the read command

----

&lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt;

---

## Our sample files

```sh
$ cat samples.txt
#&gt; zmaysA  R1      seq/zmaysA_R1.fastq
#&gt; zmaysA  R2      seq/zmaysA_R2.fastq
#&gt; zmaysB  R1      seq/zmaysB_R1.fastq
#&gt; zmaysB  R2      seq/zmaysB_R2.fastq
#&gt; zmaysC  R1      seq/zmaysC_R1.fastq
#&gt; zmaysC  R2      seq/zmaysC_R2.fastq
```

```sh
$ cut -f 3 samples.txt &gt; fastq_files.txt

$ head -n 3 fastq_files.txt
#&gt; seq/zmaysA_R1.fastq
#&gt; seq/zmaysA_R2.fastq
#&gt; seq/zmaysB_R1.fastq
```

---

## While loops

- While loops are similar to for loops,
  but instead of looping over a predefined array/list,
  the loop will keep going as long as a condition is true.

```sh
$ i=1

$ while [ $i -lt 10 ]; do
      echo $i
      i=$(expr $i + 1)
  done
#&gt; 1
#&gt; 2
#&gt; 3
#&gt; 4
#&gt; 5
#&gt; 6
#&gt; 7
#&gt; 8
#&gt; 9
```
---

## While loops (cont.)

In bash, while loops are mostly useful to loop over each line in a file,
together with the `read` command.

`while read` will be true as long as there is a line to be read,
and upon each iteration of the loop, one line will be saved in the variable:

```sh
$ cat fastq_files.txt | while read -r fastq_file; do
      
      echo "Processing file: $fastq_file"
      
      # Further processing...
  done
  
#&gt; Processing file: seq/zmaysA_R1.fastq
#&gt; Processing file: seq/zmaysA_R2.fastq
#&gt; Processing file: seq/zmaysB_R1.fastq
```

---

## While loops (cont.)

A more elegant but perhaps initially confusing syntax variant:

```sh
$ while read -r fastq_file; do
  
      echo "Processing file: $fastq_file"
  
      # Further processing...
  done &lt; fastq_files.txt

#&gt; Processing file: seq/zmaysA_R1.fastq
#&gt; Processing file: seq/zmaysA_R2.fastq
#&gt; Processing file: seq/zmaysB_R1.fastq
```

---

## While loops (cont.)

```sh
$ head -n 2 samples.txt
#&gt; zmaysA  R1      seq/zmaysA_R1.fastq
#&gt; zmaysA  R2      seq/zmaysA_R2.fastq
```

```sh
while read -r my_line; do
  
  echo "Have read line: $my_line"
  
  fastq_file=$(echo "$my_line" | cut -f 3)
  echo -e "Processing file: $fastq_file \n"
  
  # Further processing...

done &lt; samples.txt

#&gt; Have read line: zmaysA  R1      seq/zmaysA_R1.fastq
#&gt; Processing file: seq/zmaysA_R1.fastq
#&gt;
#&gt; Have read line: zmaysA  R2      seq/zmaysA_R2.fastq
#&gt; Processing file: seq/zmaysA_R2.fastq
#&gt;
```

---

## While loops (cont.)

```sh
$ head -n 2 samples.txt
#&gt; zmaysA  R1      seq/zmaysA_R1.fastq
#&gt; zmaysA  R2      seq/zmaysA_R2.fastq
```

- We can even extract columns directly!

```sh
$ while read -r sample_name readpair_member fastq_file; do
      
      echo "Processing file: $fastq_file"
      
      # Further processing...
  done &lt; metadata.txt

#&gt; Processing file: seq/zmaysA_R1.fastq
#&gt; Processing file: seq/zmaysA_R2.fastq
#&gt; Processing file: seq/zmaysB_R1.fastq
```

---

## Bash arrays

Bash arrays are like lists in Python or vectors in R.

- Create an array manually:

  ```sh
  $ sample_names=(zmaysA zmaysB zmaysC)
  ```

- Extract specific elements (note: Bash arrays are 0-indexed!):

  ```sh
  $ echo ${sample_names[0]}
  #&gt; zmaysA
  $ echo ${sample_names[2]}
  #&gt; zmaysC
  ```

- Print all elements:

  ```sh
  $ echo ${sample_names[@]}
  #&gt; zmaysA zmaysB zmaysC
  ```

---

## Bash arrays (cont.)

- Get a count of the number of elements, and element indices:
  ```sh
  echo ${#sample_names[@]}
  #&gt; 3
  
  $ echo ${!sample_names[@]}
  #&gt; 0 1 2
  ```

&lt;br&gt;

- Create an array using command substitution:

  ```sh
  $ sample_files=($(cut -f 3 samples.txt))
  
  $ sample_files=($(cat sample_names.txt))
  ```

---

## Arrays and filenames with spaces

```sh
$ all_files=($(cat files.txt))

$ for file in "${all_files[@]}"; do
      echo $file
  done
#&gt; file_A
#&gt; file_B
#&gt; file_C
#&gt; file
#&gt; D
```

---

## Accounting for problematic filenames with `IFS`

- Setting the Internal Field Separator (`IFS`), which is responsible for
  how the splitting, like above, is done, can solve this...
  ```sh
  $ OFS="$IFS"  # Store original field separator to restore later
  $ IFS="\n"    # Set new IFS to ONLY newlines
  
  $ all_files=($(cat files.txt))
  
  $ for file in "${all_files[@]}"; do
        echo $file
      done
  #&gt; file_A
  #&gt; file_B
  #&gt; file_C
  #&gt; file D
  
  $ IFS="$OFS"  # Restore original IFS
  ```

---

## Other solutions to account for problematic filenames

- Globbing over filenames will work:

  ```sh
  $ ls
  #&gt; file_A file_B file_C file D

  $ for file in file_*; do
        echo $file
      done
  #&gt; file_A
  #&gt; file_B
  #&gt; file_C
  #&gt; file D
  ```

.content-box-warning[
You may be tempted to use `ls` instead: `for file in $(ls file_*)`,
but this will **not** work for filenames with spaces.  
Looping over globbing output is a shorter syntax *and* safer.
]

---

## Other solutions to account for problematic filenames

- `while read` will also work:

  ```sh
  while read -r my_file; do
      
      echo "Processing file: $my_file"
      
      # Further processing...
  done &lt; files.txt
  ```

&lt;br&gt;

.content-box-info[
Moreover, if necessary, you can set the `IFS` more conveniently:

```sh
while IFS="\n" read -r my_file; do ...
```

With this syntax, the shell environment won't be affected elsewhere,
so you don't have to reset the `IFS`.
]

---

## Conditionals

```sh
$ if &lt;test&gt;; then
    # Command(s) if condition is true
  else
    # Commands(s) if condition is false
  fi
```

---

## Conditionals

```sh
$ filetype=$(filename | cut -d "." -f 1)
```

```sh
$ if test "$filetype" = "fastq"; then
    
    echo "Processing fastq file..."
    # Commands to process fastq file
  
  else
    
    echo "Unknown filetype!"
  
  fi
```

---

## Conditionals

```sh
$ filetype=$(filename | cut -d "." -f 1)
```


```sh
$ if [ "$filetype" = "fastq" ]; then
    
    echo "Processing fastq file..."
    # Commands to process fastq file
  
  else
    
    echo "Unknown filetype!"
  
  fi
```

--

.content-box-info[
The square brackets represent a *test statement*.  
The spaces around the inside the brackets are necessary:
`["$filetype" = "fastq"]` would fail!
]

---

## Comparison operators (Buffalo Table 12-1)

| String            | Description
|-------------------|----------------
| `-z str`          | String `str` is null (empty)
| `str1 = str2`     | Strings `str1` and `str2` are identical
| `str1 != str2` &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; | Strings `str1` and `str2` are different &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;

| Integer           | Description
|-------------------|----------------
| `int1 -eq int2`   | Integers `int1` and `int2` are equal
| `int1 -ne int2`   | Integers `int1` and `int2` are not equal
| `int1 -lt int2`   | Integer `int1` is less than `int2`
| `int1 -gt int2`   | Integer `int1` is greater than `int2`
| `int1 -le int2`   | Integer `int1` is less than or equal to `int2`
| `int1 -ge int2` &amp;nbsp; &amp;nbsp; &amp;nbsp; | Integer `int1` is greater than or equal to `int2`

--

  .content-box-q[
  Why can we not just use `int1 &gt; int2`, and so on?
  ]

---

## Another example with a comparison operator

```sh
$ n_samples=$(wc -l &lt; samples.txt)

$ if [ "$n_samples" -gt 5 ]; then
    
    # Commands to run if nr of samples &gt;5:
    echo "Processing fastq file..."
  
  else
    
    # Commands to run if nr of samples is not &gt;5:
    echo "Insufficient samples provided..."
  
  fi
```

---

## File and directory test expressions &lt;br&gt; (Buffalo Table 12-2)

| File/dir expression       | Description
|---------------------------|------------
| `-d dir`                  | Dir is a directory
| `-f file`                 | File is a file
| `-e file`                 | File exists
| `-h link`                 | Link is a link
| `-r file`                 | File is readable
| `-w file`                 | File is writable
| `-x file`                 | File is executable &lt;br&gt; (or accessible if argument is expression)

---

## File test example

```sh
$ if [ ! -f "$fastq_file" ]; then
      
      echo "Error: File not found!"
      exit 1
  
  fi
```

---

## Using the *exit status* of a command as a test

```sh
$ if grep "AAACGT" "$fastq_file" &gt; /dev/nulll; then
    
    # Commands to run if pattern is found:
    echo "Warning: contaminant detected in $fastq_file"
  
  else
  
    # Commands to run if pattern is not found:
    echo "Processing fastq file..."
    
  fi
```

```sh
$ if ! grep "AAACGT" "$fastq_file" &gt; /dev/null; then

    # Commands to run if pattern is not found:
    echo "Processing fastq file..."
    
  fi
```

---

## Side note to set the stage for scripting: basename

- Running `basename` on a filename will strip any directories in its name:
  
  ```sh
  $ basename seqs/zmaysA_R1.fastq
  #&gt; zmaysA_R1.fastq
  
  $ basename seqs/raw/fastq/zmaysA_R1.fastq
  #&gt; zmaysA_R1.fastq
  ```

--

- You can also provide a *suffix to strip* in either of these ways:

  ```sh
  $ basename seqs/zmaysA_R1.fastq ".fastq"
  #&gt; zmaysA_R1
  
  $ basename -s ".fastq" seqs/zmaysA_R1.fastq
  #&gt; zmaysA_R1
  ```

--

- If you instead want the directory part of the path, use `dirname`:

  ```sh
  $ dirname seqs/zmaysA_R1.fastq
  #&gt; seqs
  ```
  
---
class: inverse middle center

# Questions?

----

&lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt;

---
class: inverse middle center

# Bonus Materials

----

&lt;br&gt;

.left[
- ### [Extended test syntax](#extended-test)
]

&lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt;

---
background-color: #f2f5eb
name: extended-test

## Extended test syntax

```sh
$ [[ ]]
```

    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "rainbow",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
