---
title: "Week 6 - Shell scripting - I"
output:
  xaringan::moon_reader:
    seal: false
    css: ["default", "default-fonts", "slides.css", "slides_copy.css"]
    lib_dir: libs
    nature:
      highlightStyle: rainbow
      highlightLines: true
      countIncrementalSlides: false
---
class:inverse middle center

```{r setup, include=FALSE}
options(htmltools.dir.version = FALSE)

knitr::opts_chunk$set(eval = FALSE)
```

## *Week 6: Shell scripting*

----

# Part II: <br> Shell scripting...

<br> <br> <br> <br> <br>

### Jelmer Poelstra
### 2021/02/15 (updated: `r Sys.Date()`)

---
class: inverse middle center

# Overview

----

.left[
- ### [Necessary header lines and zombie scripts](#header)
- ### [Variables and quoting](#variables)
- ### [Putting it all together](#scripts)
- ### [Dressing up your script](#dress-up)
]

<br>

---

## Bash scripts

> *"Most Bash scripts in bioinformatics are simply commands organized into a
> rerunnable script with some added bells and whistles to check that files exist
> and ensuring any error causes the script to abort."* &mdash; Buffalo Ch. 12

<br>

Therefore, relatively straightforward to write with what you already know!

---
name: header

## First line of the script: *shebang* line

- Use a so-called **"*shebang*" line** as the first line of a script.
  
  This line tells the computer which program to use to run the script:
  in our case Bash, whose binary is located at `/bin/bash`.
  
  ```sh
  #!/bin/bash
  ```

- **Without this line**, we would have to call a script as follows:

  ```sh
  $ bash script.sh   # "bash" needed to indicate the interpreter
  ```

--

- **With this line**, we can submit the script to a job scheduler (next week),
  and also call the script as follows:

  ```sh
  $ ./script.sh
  ```

--

- But, for this to work, we also need to make the script executable:

  ```sh
  $ chmod u+x script.sh   # Executable for user/owner of file only
  
  $ chmod a+x script.sh   # Alt: executable for everyone (all)
  ```

---

## Bash zombie scripts &ndash; and worse!

By default, Bash will just keep running a script after it has encountered errors.

And if you try to reference a variable that hasn't been assigned,  
it won't even complain:

```sh
$ echo $non_existent_variable
```

--

.content-box-q[
Why is such behavior a bad idea in scripts?
]

--

- Let's accidentally delete the filesystem!
  ```sh
  TMPDIR=output/tmp/$sample/
  # rest of script...
  rm -rf $TMPPDIR/*   ## DONT TRY THIS!
  ```

- As for errors, you may never notice them if they're subtle and don't cause
  everything else to error out &ndash; but they could still make all the output
  of the zombie script worthless!

---

## Three necessary options for robust scripts

With these settings, the script terminates, with appropriate error message, if:

- `set -u` &mdash; An unset variable is referenced

- `set -e` &mdash; Almost any errors occurs

- `set -o pipefail` &mdash; An error occurs within a shell "pipeline"

<br>

```sh
set -u
set -e
set -o pipefail
```

Or, in one line:

```sh
set -u -e -o pipefail
```

---

## Our script &ndash;*any* shell script&ndash; so far 

```sh
#!/bin/bash

set -u -e -o pipefail
```

<br>

.content-box-info[
Another useful setting, especially for debugging, is `set -x`,  
which will print every line of the script as it is executed:

```sh
set -x 
```
]

---
class: inverse middle center
name: variables

# Variables and quoting

----

<br> <br> <br> <br> <br>

---

## Variables

> *"Processing pipelines having numerous settings that should be stored in variables
(e.g., which directories to store results in, parameter values for commands,
input files, etc.).
Storing these settings in a variable defined at the top of the file makes adjusting
settings and rerunning your pipelines much easier. Rather than having to change
numerous hardcoded values in your scripts, using variables to store settings means
you only have to change one value—the value you’ve assigned to the variable."*
&mdash; Buffalo ch. 12

- Alternatively/additionally, can use a configuration file.

---

## Assigning and using shell variables

A variable is nothing more than a pointer to the actual data.

.pull-left[
**Assign** a variable (no **`$`**):

```sh
# Any string:
my_name=Jelmer
```
]

.pull-right[
**Recall** a variable (with **`$`**):

```sh
$ echo $my_name
# Jelmer
  ```
]

--

.pull-left[
```sh
# A file name:
my_file="README.txt"
```
]

.pull-right[
```sh
$ ls -lh $my_file
# -rw-r--r-- 1 jelmer PAS0471 568 Dec  7 09:58 README.txt
```
]

--

.pull-left[  
```sh
# Use "command substitution"
# to assign a command's output
today=$(date +%F)
```
]

.pull-right[
```sh
$ touch README_$today.txt
$ ls README_*
# README_2020-12-10.txt
```
]

--

.pull-left[
Pre-existing variables:
("**Environment variables**")
]

.pull-right[
```sh
$ echo $USER
# jelmer
```
]

---

## Sidenote: Quoting and embracing variables

```sh
$ today="Thu, Feb 8"
$ echo $today

$ touch README_$today.txt
$ ls
#> .txt  Feb  README_Thu,

$ touch README_"$today".txt
$ ls
#> 'README_Thu, Feb 8.txt'
```

```sh
$ touch README_$today_final.txt
#> README_.txt
```

```sh
$ touch README_"$today"_final.txt
#> 'README_Thu, Feb 8_final.txt'
```

---

## Sidenote: Quoting and embracing variables (cont.)

```sh
$ touch README_${today}_final.txt
#> 'README_Thu, Feb 8_final.txt'

$ touch README_"${today}"_final.txt
#> 'README_Thu, Feb 8_final.txt'
```

---

## Command-line arguments for scripts

- When you call a script, you can give it command-line arguments,  
  much like when you provide commands like `ls` with arguments:

  ```sh
  $ ./name-script.sh John Doe
  ```

- Inside the script, these arguments are *automatically* assigned to the variables
  `$1` ("John" above), `$2` ("Doe" above), and so on:

  ```sh
  #!/bin/bash
  
  echo "First argument: $1"   # John
  echo "Second argument: $2"  # Doe
  echo "Full name: $1 $2"
  ```

  ```sh
  $ ./name-script.sh John Doe
  #> First argument: John
  #> Second argument: Doe
  #> Full name: John Doe
  ```

---

## Command-line arguments for scripts (cont.)

- Inside the script, it is good practice to reassign these variables
  to ones with more descriptive names:

  ```sh
  #!/bin/bash
  
  first_name=$1
  last_name=$2
  
  echo "First argument: $first_name"
  echo "Second argument: $last_name"
  echo "Full name: $first_name $last_name"
  ```

<br>

.content-box-info[
- `$0` contains the filename of the script.

- `$#` contains the number of command-line arguments that were provided.
]

---

## A simple shell script example

```sh
head -n 2 "$1"
echo "---"
tail -n 2 "$1"
```

```sh
$ bash headtail.sh samples.txt
$ bash headtail.sh egfr_flank.fasta
```

```sh
#!/bin/bash
set -u -e -o pipefail

head -n 2 "$1"
echo "---"
tail -n 2 "$1"
```

```sh
$ chmod a+x headtail.sh

$ ./headtail.sh samples.txt
```

---

## `r icon::fa("user-edit")` Your turn: A simple script

Write a script that prints a specific line, identified by its line number,
from a file.

- Make the line number argument 1 (`$1`), and the filename argument 2 (`$2`). 

- If you don't remember how to print a specific line, click on the hint below.

<br>

<details>
<summary><strong>Hint!</strong></summary>
<br>
To print a specific line number, say line 37 from <code>file.txt</code>,
you can use: <br> <code>head -n 37 file.txt | tail -n 1</code>
or <code>sed -n '37p' file.txt</code>.
<br>
</details>

---

## `r icon::fa("user-edit")` Solution: A simple script

- Script `line.sh`:

  ```sh
  #!/bin/bash
  set -u -e -o pipefail
  
  head -n "$1" "$2" | tail -n 1
  ```

- To execute:

  ```sh
  $ chmod a+x line.sh
  $ ./line.sh 4 samples.txt
  ```

---
class: inverse middle center
name: scripts

# Putting it all together: <br> Functional, nontrivial scripts

----

<br> <br> <br> <br> <br>

---

## Buffalo's first script

```sh
#!/bin/bash
set -e -u -o pipefail

# Specify the input samples file (3rd column = path to FASTQ file):
sample_info=samples.txt

# Create a Bash array from the third column of "$sample_info":
sample_files=($(cut -f 3 "$sample_info"))

# Loop through the array:
for fastq_file in ${sample_files[@]}; do
    
    # Strip .fastq from each FASTQ file, and add suffix:
    results_file="$(basename $fastq_file .fastq)-stats.txt"
    
    # Run "fastq_stat" on a file:
    fastq_stat "$fastq_file" > stats/$results_file

done
```

- Save this script as `fastq_stat_loop.sh`.

---

## Buffalo's second script

```sh
#!/bin/bash
set -e -u -o pipefail

# Specify the input samples file (3rd column = path to FASTQ file):
sample_info=samples.txt

# Our reference genome:
ref=zmays_AGPv3.20.fa

# Create a Bash array from the first column (sample names).
# Because there are duplicate sample names, we call uniq
sample_names=($(cut -f 1 "$sample_info" | uniq))

# Loop through the array:
for sample in ${sample_names[@]}; do
    
    # Create an output file from the sample name:
    results_file="${sample}.sam"
    
    # Run the sequence alignment with "bwa mem":
    bwa mem $ref ${sample}_R1.fastq ${sample}_R2.fastq \
        > $results_file

done
```

---
class: inverse middle center
name: arrays

# Dressing up your scripts to <br> increase robustness and user-friendliness

----

<br> <br> <br> <br> <br>

---

## Dressing up your scripts to <br> increase robustness and user-friendliness

- Let's go back to our `line.sh` script to keep things manageable,
  and have arguments to work with:

```sh
  #!/bin/bash
  set -u -e -o pipefail
  
  head -n "$1" "$2" | tail -n 1
```

<br>

.content-box-q[
What could we do to be make this more robust / foolproof?
]

---

## Assign the arguments to named variables

- Using named variables will make the rest of the script more readable:
```sh
line="$1"
file="$2"
```

- Instead of:
```sh
head -n "$1" "$2" | tail -n 1
```

- We can now say:
```sh
head -n "$line" "$file" | tail -n 1
```

---

## Report what's going on

- While you probably don't want a small utility script like `line.sh` to be
  chatty, this is often useful for longer-running or more complex scripts:
  
  ```sh
  echo "Starting script $0"
  date # Print date & time to log & time running duration
  echo "Input file: $file"
  echo "Requested line number: $line"
  
  head -n "$line" "$file" | tail -n 1
  
  echo "Done with script $0"
  date
  ```

---

## Conduct tests

```sh
$ if [ "$#" -lt 2 ] || [ "$#" -gt 2 ]; then
    echo "Error: wrong number of arguments"
    echo "You provided $# arguments, while 2 are required."
    echo "Usage: line.sh <line-number> <file>"
    exit 1
  fi
```

--

.content-box-info[
With `exit 1`, the *exit status* of our script is 1.

In bash, an exit status of **0 means success**,  
and **any other integer, including 1, means failure**.

This includes cases like whether `grep` found a match:
```sh
$ echo "sampleA.fastq.gz" | grep "fastq"; echo $?
#> sampleA.fastq.gz
#> 0
```
]

---

## Conduct tests

```sh
$ if [ "$#" -lt 2 ] || [ "$#" -gt 2 ]; then
    echo "Error: wrong number of arguments"
    echo "You provided $# arguments, while 2 are required."
    echo "Usage: line.sh <line-number> <file>"
    exit 1
  fi
```

.content-box-info[
With `exit 1`, the *exit status* of our script is 1.

In bash, an exit status of **0 means success**,  
and **any other integer, including 1, means failure**.

This includes cases like whether `grep` found a match:
```sh
$ echo "sampleA.fastq.gz" | grep "fastx"; echo $?
#> 1
```
]

---

## Conduct tests (cont.)

```sh
if [ ! -f $file ] || [ ! -r $file ]; then
  echo "Error: can't open file"
  echo "Second argument should be a readable file"
  echo "You provided: $2"
  exit 1
fi
```

---

## Conduct tests (cont.)

- Test whether the requested line number is valid
  (will also implicitly test whether it's a number at all):
  
  ```sh
  if [ $line -gt $(wc -l < $file) ] || [ ! $line -gt 0 ]; then
    echo "Error: Invalid line number"
    echo "Number should be >0 and at <= the file's nr. of lines"
    echo "The file contains $(wc -l < $2) lines; you provided $1."
    exit 1
  fi
  ```

- Alternatively, you could decide to simply print the last line
  when a too-high line number is requested:

  ```sh
  if [ $line -gt $(wc -l < $file) ]; then
    line=$(wc -l < $file)
    echo "Requested line exceeded line count; printing last line."
  fi
  ```

---

## Parameter expansion to provide default values

```sh
line=${1:-10}             # Set 10 as the default value for $1

rm_unpaired=${3:-true}    # Set true as the default value for $3
```

This will also help you avoid that a script fails with `set -u` because the
variable is not set:

```sh
fastq_forward=$1
fastq_reverse=$2
rm_unpaired=${3:-true}
```

```sh
$ trim.sh sampleA_R1.fastq sampleA_R2.fastq false

# Will error out if no default value provided due to `set -u`:
$ trim.sh sampleA_R1.fastq sampleA_R2.fastq
```

.content-box-info[
You can do a lot more with parameter expansion - see XXX.
]


---

## Conduct tests (cont.)

- This may start to seem silly &mdash; but extensive testing can be pretty useful,
  and a time-saver eventually.
  Especially for long-running scripts,
  or scripts that you reuse and perhaps share with others.


---

## A word of advice / caution

While different strategies are certainly possible, as a general rule of thumb:

.content-box-green[
**Bash scripts are best kept relatively simple.**
]

<br>

**If you find yourself writing very long and complicated shell scripts:**

- Break up your scripts into smaller units!

- If you're connecting many scripts in an intricate pipeline =>  
  switch this part to a workflow management system (Week 13!)

- If neither of the above two options applies: switch to Python (or R).
  
---
class: inverse middle center

# Questions?

----

<br> <br> <br> <br>

---
class: inverse middle center

# Bonus Materials

----

<br>

.left[
- ### [More on quoting in shell commands](#quote)
- ### [Using a Help function](#help)
- ### [Parsing non-positional arguments with getopts](#getops)
]

<br> <br> <br> <br>

---
background-color: #f2f5eb
name: quote

## More on quoting in shell commands

Recall that we can use quoting to escape special characters:

```sh
$ cd XXX

$ echo *
# Should show a list of files

$ echo "*"
# *
```

But what about this?

```sh
$ echo "* and this is my shell: $SHELL"
# * and this is my shell: /bin/bash
```

We can use *single quotes* to also escape the "**`$`**":
```sh
$ echo '* and this is my shell: $SHELL'
# * and this is my shell: $SHELL
```
