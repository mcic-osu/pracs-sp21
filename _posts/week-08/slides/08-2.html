<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Week 8/9 - First steps with Python - II</title>
    <meta charset="utf-8" />
    <script src="libs/header-attrs/header-attrs.js"></script>
    <link href="libs/remark-css/default.css" rel="stylesheet" />
    <link href="libs/remark-css/default-fonts.css" rel="stylesheet" />
    <script src="libs/fabric/fabric.min.js"></script>
    <link href="libs/xaringanExtra-scribble/scribble.css" rel="stylesheet" />
    <script src="libs/xaringanExtra-scribble/scribble.js"></script>
    <script>document.addEventListener('DOMContentLoaded', function() { window.xeScribble = new Scribble({"pen_color":["#FF0000"],"pen_size":3,"eraser_size":30}) })</script>
    <link href="libs/panelset/panelset.css" rel="stylesheet" />
    <script src="libs/panelset/panelset.js"></script>
    <script src="libs/clipboard/clipboard.min.js"></script>
    <link href="libs/xaringanExtra-clipboard/xaringanExtra-clipboard.css" rel="stylesheet" />
    <script src="libs/xaringanExtra-clipboard/xaringanExtra-clipboard.js"></script>
    <script>window.xaringanExtraClipboard(null, {"button":"Copy Code","success":"Copied!","error":"Press Ctrl+C to Copy"})</script>
    <script src="libs/mark.js/mark.min.js"></script>
    <link href="libs/xaringanExtra-search/search.css" rel="stylesheet" />
    <script src="libs/xaringanExtra-search/search.js"></script>
    <script>window.addEventListener('load', function() { window.xeSearch = new RemarkSearch({"position":"bottom-left","caseSensitive":false,"showIcon":true,"autoSearch":true}) })</script>
    <link rel="stylesheet" href="slides.css" type="text/css" />
    <link rel="stylesheet" href="slides_copy.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">

class:inverse middle center





# *Week 8 - First steps with Python*

----

# II: Data structures

&lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt;

### Jelmer Poelstra
### 2021/03/04 &amp; 2021/03/09 (updated: 2021-03-12)

---
class: inverse middle center

# Overview

----

.left[
- ### [Lists](#lists)
- ### [Dictionaries](#dicts)
- ### [Tuples](#tuples)
- ### [Sets](#sets)
]

---
class: center middle inverse
name: lists

# Lists

-----

&lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt;

---

## Lists

**A list stores a collection of items, similar to arrays in Bash.**

A list is denoted with square brackets `[]`,
and with individual items (elements) separated by commas.
  
- Two ways to create an empty list:

  ```python
  new_list = []
  
  another_list = list()
  ```

- Create a list with values &amp;ndash; note that they don't have to be of the
  same type:
  
  ```python
  first_list = ["a", "e", "g"]
  second_list = [45, 33, 99]
  third_list = [3, 2.44, "green", True]
  ```
  
--

- We can also convert other object types, such as a string, into a list:
  
  ```python
  a = list("0123456789")
  a
  #&gt; ['0' ,'1', '2', '3', '4', '5', '6', '7', '8', '9']
  ```

---

## Accessing list elements &amp;ndash; and zero-indexing

- We can access items within a list by indicating position(s)
  within square brackets. For instance:

  ```python
  my_list = ['a', 'b', 'c', 'd', 'e']
  
  my_list[1]
  #&gt; 'b'
  ```

  But this returns the *second* item!

--

- **Python starts counting at 0**,
  so the first element corresponds to index 0:

  ```python
  my_list[0]
  #&gt; 'a'
  ```

---

## Accessing list elements &amp;ndash; and zero-indexing (cont.)

- Moreover, when using *ranges*, such as with a colon `:`,  
  **the item corresponding to the last index is not included:**

  ```python
  # my_list = ['a', 'b', 'c', 'd', 'e']
  
  my_list[0:3]    # Elements 1, 2 and 3
  #&gt; ['a', 'b', 'c']
  
  my_list[1:3]    # Elements 2 and 3
  #&gt; ['b', 'c']
  ```

--

- Therefore, a range of two successive indices returns a single-item list:
  
  ```python
  my_list[0:1]    # First item in single-element list
  # ['a']           
  
  # Use a single index to return a "str":
  my_list[0]      # First item as a "str"
  #&gt; 'a'
  ```

---

## Zero-indexing with half-open intervals

&lt;br&gt;

&lt;figure&gt;
&lt;p align="center"&gt;
&lt;img src=img/indexing1.svg width="100%"&gt;
&lt;/p&gt;
&lt;/figure&gt;

---

## Zero-indexing with half-open intervals

&lt;br&gt;

&lt;figure&gt;
&lt;p align="center"&gt;
&lt;img src=img/indexing2.svg width="100%"&gt;
&lt;/p&gt;
&lt;/figure&gt;

---

## More indexing with a colon (i.e., "slicing")

- When using a colon to indicate a range,
  as we did in the previous slide,
  numbers on either side of the colon are optional:

  ```python
  # my_list = ['a', 'b', 'c', 'd', 'e']
  
  # From the first element until element 3 (noninclusive):
  my_list[:3]      
  #&gt; ['a', 'b', 'c']
  
  # From element 4 to the last element:
  my_list[3:]      
  #&gt; ['d', 'e']
  ```

--

- As it stands to reason, we can therefore return the whole list with `[:]`:

  ```python
  my_list[:]
  #&gt; ['a', 'b', 'c', 'd', 'e']
  ```

---

## Indexing with negative numbers

- You can use *negative numbers* to index starting from the end:

  ```python
  # my_list = ['a', 'b', 'c', 'd', 'e']
  
  my_list[-1]     # Last element
  #&gt; 'e'
  
  my_list[-2]     # Second-to-last element
  #&gt; 'd'
  ```

- And this works with ranges as well - the default direction is still positive:

  ```python
  my_list[-3:-1]  # Third-to-last to last element (noninclusive)
  #&gt; ['c', 'd']
  ```

---

## Indexing with negative numbers

&lt;figure&gt;
&lt;p align="center"&gt;
&lt;img src=img/indexing3.svg width="100%"&gt;
&lt;/p&gt;
&lt;/figure&gt;

---

## Indexing with negative numbers

&lt;figure&gt;
&lt;p align="center"&gt;
&lt;img src=img/indexing4.svg width="100%"&gt;
&lt;/p&gt;
&lt;/figure&gt;

---

## Indexing with two colons

When using **two colons**, the third element is the direction and stride.

- The default stride is `1` (positive 1):

  ```python
  # my_list = ['a', 'b', 'c', 'd', 'e']
  
  my_list[:3:1]
  #&gt; ['a', 'b', 'c']
  ```

- We can take every second element with a stride of `2`:  
  
  ```python
  my_list[::2]
  #&gt; ['a', 'c', 'e']
  ```

- And we can reverse the list with a stride of `-1`:

  ```python
  my_list[::-1]    # Go backward with stride 1 and take whole list
  #&gt; ['e', 'd', 'c', 'b', 'a']             
  ```

---

## Chaining indexing

- Since we can also index strings:

  ```python
  seq = 'GTACAG'
  seq[3]
  #&gt; C
  ```

- ...we can use index chaining to, for example, index a string inside a list:

  ```python
  seqlist = ['AACGT', 'GTACAG', 'CTCTA']
  seqlist[1][3]
  #&gt; C
  ```

---

## Bad indexing

- When your index attempt contains a contradiction between the *implicit*
  direction (to:from) and the *explicit* direction (stride),
  an empty list is returned:

  ```python
  my_list[-1:-3]    # With no stride indicated, it defaults to 1
  #&gt; []
  ```

--

- When your indexing range reaches beyond the last element,
  everything until the last element will simply be returned:
  
  ```python
  my_list[0:10]
  #&gt; ['a', 'b', 'c', 'd', 'e']
  ```

--

- But when you try to access an individual nonexistent element,  
  you will get an error:

  ```python
  my_list[5]
  #&gt; ...
  #&gt; IndexError: list index out of range
  ```

---

## Operating on lists with `+` and `*`

- Like strings, we can concatenate two lists with `+`:

  ```python
  # my_list = ['a', 'b', 'c', 'd', 'e']
  # a = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']
  a + my_list
  #&gt; ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e']
  ```

--

- We *can't* add individual elements like this:

  ```python
  a + 1
  #&gt; TypeError: can only concatenate list (not "int") to list
  ```

- But we can add a list that we define on the fly, including a single-element one:

  ```python
  a + [1]
  #&gt; ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 1]
  ```

---

## Operating on lists with `+` and `*`

- Using the multiply operator, the list contents will be *repeated* n times:

  ```python
  a * 2
  #&gt; ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9']
  
  samples = ['red'] * 5
  samples
  # ['red', 'red', 'red', 'red', 'red']
  ```

--

&lt;br&gt;

.content-box-info[
Like the `+` operator, the `*` operator works equivalently on lists and strings:

```python
my_repeat = "AGAAG"
my_repeat * 3
#&gt; 'AGAAGAGAAGAGAAG'
```
]

---

## Side note: No automatic element-wise actions

.content-box-info[
As the addition and multiplication of lists above already hinted at,
Python operations do not by default act element-wise
(unlike in R, where many operations are *vectorized*).

To operate on each element of a list, we can:

- Use a loop (next week), a *list comprehension* (next week),
  or the `map()` function.

- Use *arrays* from the NumPy module to get R-like behavior.
]

---
name: resume-here

## Setup for Tuesday Mar 9 (same as before)

- **In the OnDemand form for VS Code, set the Working Directory to
  `/fs/ess/PAS1855/users/&lt;your-username&gt;`.**

- Open your `week08.py` from last Thu (or start a new file).

- A Python environment should load: see the bottom bar.
  If it's not the Python in your Conda environment
  (`Python 3.9.2 64-bit (ipy-env: conda)`),
  click the bottom bar and select it.

- If you have no code in the file, type a dummy line like `5+5`.

- Right-click in the editor/script and select
  "Run Selection/Line in Python Interactive Window".
  *(Or &lt;kbd&gt;Shift&lt;/kbd&gt;+&lt;kbd&gt;Enter&lt;/kbd&gt;.)*

.content-box-info[
Is this doesn't work, we can troubleshoot after class again &amp;ndash;
for now, open a terminal in VS Code and start a regular Python prompt with:

```sh
$ python3
```
]

---

## Recap - we talked about:

- Using Python as a calculator
- Variables and their types
- Working with strings
- Methods and functions
- Our first data structure: lists
- Indexing

&lt;figure&gt;
&lt;p align="center"&gt;
&lt;img src=img/donald_knuth.png width="90%"&gt;
https://xkcd.com/163/
&lt;/p&gt;
&lt;/figure&gt;

---

## Modifying lists

- We can *update* an element using index notation:

  ```python
  my_list = ['a', 'b', 'c', 'd', 'e']
  my_list[0] = "x"
  my_list
  #&gt; ['x', 'b', 'c', 'd', 'e']
  ```

--

- To append an element to the end of the list, use the method `append()`:

  ```python
  my_list.append('f')          # append: single item
  my_list
  # ['x', 'b', 'c', 'd', 'e', 'f']
  ```
  
- To remove all elements from the list, use the method `clear()`:

  ```python
  my_list.clear()
  my_list
  #&gt; []
  ```

---

## Misc. list methods

```python
seq = list("TKAAVVNFT")
seq
#&gt; ['T', 'K', 'A', 'A', 'V', 'V', 'N', 'F', 'T']
```
  
- `count()` &amp;ndash; Count occurrences of a certain item in the list:
  
  ```python
  seq.count("V")
  #&gt; 2
  ```

- `index()` &amp;ndash; Return the index corresponding to first occurrence of an
  item:

  ```python
  seq.index("V")
  #&gt; 4
  ```

---

## Misc. list methods (cont.)

- `sort()` &amp;ndash; Sort the list:

  ```python
  # seq = ['T', 'K', 'A', 'A', 'V', 'V', 'N', 'F', 'T']
  seq.sort()
  seq
  #&gt; ['A', 'A', 'F', 'K', 'N', 'T', 'V', 'V']
  ```

--

- `reverse()` &amp;ndash; Reverse the order of the elements:

  ```python
  seq.reverse()
  seq
  #&gt; ['V', 'V', 'T', 'N', 'K', 'F', 'A', 'A']
  ```

---

## &lt;i class="fa fa-user-edit"&gt;&lt;/i&gt; Intermezzo 3.2 - Part I

.panelset[
.panel[.panel-name[Questions]

1. Define a list `a = [1, 1, 2, 3, 5, 8]`.

2. Extract `[5, 8]` in two different ways (with positive and negative indices).

3. Add an element (item) containing `13` at the end of the list.
]

.panel[.panel-name[Solutions]

1. Define a list:
  
   ```python
   a = [1, 1, 2, 3, 5, 8]
   ```

2. Extract `[5, 8]` in two ways:
   
   ```python
   a[4:]    # Or a[4:6]
   a[-2:]
   ```
   
3. Add an item:

   ```python
   a.append(13)
   ```
]
]

---
class: center middle inverse
name: dicts

# Dictionaries

-----

&lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt;

---

## Dictionaries

Dictionaries are like lists in which the elements (**values**) are indexed by
**keys**.

- Create an empty dictionary using curly braces or the `dict()` function:

  ```python
  empty_dict_1 = {}
  empty_dict_2 = dict()
  ```

- And one with items using `key: value` notation inside curly braces:

  ```python
  GenomeSize = {"Homo sapiens": 3200.0,
                  "Escherichia coli": 4.6,
                  "Arabidopsis thaliana": 157.0}
  GenomeSize
  #&gt; {'Arabidopsis thaliana ' : 157.0,
  #&gt;  'Escherichia coli' : 4.6,
  #&gt;  'Homo sapiens' : 3200.0}
  ```

- The order of the keys does not matter,
  and is in fact not retained as it was entered!
  
---

## Accessing dictionary values

- In dictionaries, individual *values* cannot be accessed by referencing by
  index (position).
  Instead, we use the name of the corresponding *key*:
  
  ```python
  GenomeSize["Arabidopsis thaliana"]
  #&gt; 157.0
  ```
  
  Note that here, we are using square brackets and not curly braces, using
  the syntax `dictionary_name["key_name"]` to get the corresponding value.


---

## Modifying dictionaries

- New values can be added simply by assigning a new key:

  ```python
  GenomeSize["Saccharomyces cerevisiae"] = 12.1
  GenomeSize
  #&gt; {' Arabidopsis thaliana': 157.0,
  #&gt; 'Escherichia coli': 4.6,
  #&gt; 'Homo sapiens': 3200.0,
  #&gt; 'Saccharomyces cerevisiae': 12.1}
  ```

--

- If the key-value pair already existed, nothing happens:

  ```python
  GenomeSize["Escherichia coli"] = 4.6
  ```

--

- But the old value will be overwritten if the new one is different:
  
  ```python
  GenomeSize["Homo sapiens"] = 3201.1
  GenomeSize
  #&gt; {'Arabidopsis thaliana': 157.0,
  #&gt; 'Escherichia coli': 4.6,
  #&gt; 'Homo sapiens': 3201.1,
  #&gt; 'Saccharomyces cerevisiae': 12.1}
  ```

---

## Functions and methods for dictionaries

- The methods **`keys()`** and **`values()`** create list-like objects from the keys
  and values:
  
  ```python
  GenomeSize.keys()
  #&gt; dict_keys(['Arabidopsis thaliana', 'Saccharomyces cerevisiae'])
  
  GenomeSize.values()
  #&gt; dict_values([157.0, 12.1])
  ```

- And similarly **`items()`** returns each full item, i.e. each key-value pair:

  ```python
  GenomeSize.items()
  #&gt; dict_items([('Arabidopsis thaliana', 157.0), ('Saccharomyces cerevisiae', 12.1)])
  ```
  
---

## Functions and methods for dictionaries (cont.)

- We can merge two dictionaries using `update()`:

  ```python
  D1 = {"a": 1, "b": 2, "c": 3}
  D2 = {"a": 2, "d": 4, "e": 5}
  
  D1.update(D2)
  D1
  #&gt; {'d': 4, 'e': 5, 'b': 2, 'a': 2, 'c': 3}
  ```

  With `update()`, the order matters: for keys present in both dictionaries
  but with different values, the value of the *second* dictionary will
  overwrite that of the first.
  
---

## Functions and methods for dictionaries (cont.)

- We saw that we can extract a value with square brackets,
  but we can also use the `get()` method.
  This will make a difference when the key does not exist &amp;ndash;
  and we can even specify a default value with `get()`:
  
  ```python
  GenomeSize["Mus musculus"]
  #&gt; KeyError: 'Mus musculus'
  
  GenomeSize.get("Mus musculus")
  #&gt; 
  
  GenomeSize.get("Mus musculus", -10)
  #&gt; -10
  ```

--

.content-box-info[
In the second example, nothing was printed,
but `get()` actually returned `None`,
Python's keyword to define a null value.  
We can see this by using the `print()` function:

```python
print(GenomeSize.get("Allium cepa"))
#&gt; None
```
]

---

## More complex dictionaries

- Values of dictionaries can also be lists:

  ```python
  codon_dict = {"Phe": ['UUU', 'UUC'],
                  "Val": ['GUU', 'GUC', 'GUA', 'GUG'],
                  "Met": ['AUG']}
  ```


- And values of dictionaries can also be dictionaries themselves:

  ```python
  RNA_dict = {"bases": ['A', 'U', 'C', 'G']}
  
  RNA_dict["codons"] = codon_dict
  RNA_dict
  
  RNA_dict
  #&gt; {'bases': ['A', 'U', 'C', 'G'],
  #&gt;  'codons': {'Phe': ['UUU', 'UUC'],
  #&gt;             'Val': ['GUU', 'GUC', 'GUA', 'GUG'],
  #&gt;             'Met': ['AUG']}}
  ```

---

## &lt;i class="fa fa-user-edit"&gt;&lt;/i&gt; Intermezzo 3.2 - Part II

.panelset[
.panel[.panel-name[Questions]

1. Define a dictionary `codons = {'Met': 'AUG', 'Phe': 'UUU'}`.

2. Add the element `Trp` with value `"UGG"`. 

3. Update the value of `Phe` to be `['UUU', 'UUC']`.
]

.panel[.panel-name[Solutions]

1. Define a dictionary:
   
   ```python
   codons = {'Met': 'AUG', 'Phe': 'UUU'}
   ```
   
2. Add an item:

   ```python
   codons["Trp"] = 'UGG'
   ```

3. Update an item:

   ```python
   codons['Phe'] = ['UUU', 'UUC']
   ```
   
]
]

---
class: center middle inverse
name: tuples

# Tuples

-----

&lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt;

---

## Tuples

Tuples are similar to lists, in that they contain a sequence of values of any
type, **but they are immutable:** the values cannot be changed once the
tuple has been defined.

This behavior provides write-protection, and makes tuples faster than lists.

- Empty tuples are created using parentheses `()` or `tuple()`:
  
  ```python
  empty_tuple_1 = ()
  empty_tuple_2 = tuple()
  ```

- Tuples that contain items are created using parentheses,  
  and a trailing comma is needed when creating a single-item tuple:

  ```python
  my_tuple = (1, "two", 3)
  single_element_tuple = (4, )   # Trailing comma needed
  ```

---

## Tuples (cont.)

- Tuples can be indexed like lists:

  ```python
  my_tuple[0]
  #&gt; 1
  ```

- But when we try to modify a value, we get an error:

  ```python
  my_tuple[0] = 33
  #&gt; TypeError: ' tuple ' object does not support item assignment
  ```

---

## Methods for tuples

Because they can't be modified, tuples only have two methods:

- `count()` to count the number of occurrences of an element:

  ```python
  tt = (1, 1, 1, 1, 2, 2, 4)
  
  tt.count(1)
  #&gt; 4
  ```

- `index()` to return the index of the first occurrence of an element:
 
  ```python
  tt.index(2) 
  #&gt; 4
  ```

---
class: center middle inverse
name: sets

# Sets

-----

&lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt;

---

## Sets

**Sets are lists with no duplicate entries.**

- Sets can be created with curly braces `{}` &amp;mdash; like dictionaries (!),  
  but the syntax of the elements will make clear which you mean:
  
  ```python
  set1 = {3, 4, 5, 6}
  ```

- However, we can't use just curly braces to create an *empty* set becuase that
  is reserved for creating an empty dictionary &amp;ndash;
  we can therefore only use `set()` to do so:
  
  ```python
  empty_set = set()
  ```

---

## Sets (cont.)

- In practice, it is common to create a set from a list &amp;ndash;  
  this is a way to quickly **get all unique elements within a list**:
  
  ```python
  my_list = [5, 6, 7, 7, 7, 8, 9, 9]
  
  set2 = set(my_list)
  set2
  #&gt; {5, 6, 7, 8, 9}
  ```

&lt;br&gt;

- Using the `add()` method, we can add a value to a set, with a twist &amp;ndash;
  **nothing will happen if the value is already present in the set**:
  
  ```py
  set2.add(5)
  
  set2
  #&gt; {5, 6, 7, 8, 9}
  ```

---

## Comparing two sets

We can use logical operators to look for shared and non-shared elements
between different lists:

- `setA &amp; setB` &amp;ndash; intersect: get elements present in *both sets*
- `setA | setB` &amp;ndash; union: get elements present in *at least one set*
- `setA ^ setB` &amp;ndash; symmetric difference: get elements present in *one set*
- `setA - setB` &amp;ndash; asymmetric difference: get elements only in `setA`
- `setB - setA` &amp;ndash; asymmetric difference: get elements only in `setB`

For example:

```python
#set1 = {3, 4, 5, 6}
#set2 = {5, 6, 7, 8, 9}

b &amp; c
#&gt; {5, 6}

b | c
#&gt; {3, 4, 5, 6, 7, 8, 9}

b ^ c
#&gt; {3, 4, 7, 8, 9}
```

---

## Comparing two sets

&lt;figure&gt;
&lt;p align="center"&gt;
&lt;img src=img/sets.svg width="75%"&gt;
&lt;/p&gt;
&lt;/figure&gt;

---

## Summary of data structures

| structure | bracket type   | create empty   | create non-empty
|-----------|----------------|----------------|--------
| **list**      | `[]`           | `[]`           | `[1, 2]`
| **dictionary**| `{}`           | `{}`           | `{1: "a", 2: "b"}`
| **tuple**     | `()`           | `()`           | `(1, 2)`
| **set**       | `{}`           | `set()`        | `{1, 2}`

&lt;br&gt;

--

```python
type([1, 2])
#&gt; list

type({1: "a", 2: "b"})
#&gt; dict

type((1, 2))
#&gt; tuple

type({1, 2})
#&gt; set
```

---
class: center middle inverse

# Questions?

-----

&lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt;

---
class: inverse middle center

# Bonus Material

----

&lt;br&gt;

.left[
- ### [Removing items from lists and dictionaries](#rm)
- ### [More on comparing sets](#more-sets)
]

&lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt;

---
background-color: #f2f5eb
name: rm

## Removing items from lists

- To delete one or more items *by index*, use the *function* `del()`:
  
  ```python
  del(my_list[2:4])        # Delete 3rd and 4th element 
  a
  #&gt; ['x', 'b', 'e', 'f']
  ```
 
 
- `pop()` &amp;ndash; Remove the last item in the list *and return it*:

  ```python
  seq_last = seq.pop()
  seq
  #&gt; ['T', 'K', 'A' , 'A' , 'V', 'V' ,'N', 'F']
  seq_last
  #&gt; 'T'
  ```

---
background-color: #f2f5eb

## Removing items from dictionaries

- As with lists, items can be deleted with the `del()` function:

  ```python
  del(GenomeSize['Homo sapiens'])
  ```

&lt;br&gt;

- `pop()` removes the specified key and returns the corresponding value:

  ```python
  GenomeSize.pop("Escherichia coli")
  #&gt; 4.6
  
  GenomeSize
  #&gt; {'Arabidopsis thaliana': 157.0,
  #&gt; 'Saccharomyces cerevisiae': 12.1}
  ```

---
background-color: #f2f5eb
name: more-sets

## *Methods* to compare two sets

We can do the same operations that we did above with operators like `+` and `-`
with the methods `intersection()`, `union()`, `symmetric_difference()`,
and `difference()`:

```python
s1 = {1, 2, 3, 4}
s2 = {4, 5, 6}

s1.intersection(s2)         # Equivalent to: s1 &amp; s2
#&gt; {4}

s1.union(s2)                # Equivalent to: s1 | s2
#&gt; {1, 2, 3, 4, 5, 6}

s1.symmetric_difference(s2) # Equivalent to: s1 ^ s2
#&gt; {1, 2, 3, 5, 6}

s1.difference(s2)           # In set 1 but not in set 2
#&gt; {1, 2, 3}

s2.difference(s1)           # In set 2 but not in set 1
#&gt; {5, 6}
```

---
background-color: #f2f5eb

## *Methods* to compare two sets

We can also test whether sets are *subsets* or *supersets* of each other.

- Set 1 is a subset of set 2 if if s2 contains all its elements,
  and optionally others too:

  ```python
  # s1 = {1, 2, 3, 4}
  # s2 = {4, 5, 6}
  
  s1.issubset(s2)
  #&gt; False
  ```

- Set 1 is a superset of set 2 if set 1 contains all the elements in set 2,
  and optionally others too:
  
  ```python
  s1.issuperset(s2)
  #&gt; False
  ```
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "rainbow",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
