---
title: "Week 11 - Python: Scientific computing"
output:
  xaringan::moon_reader:
    seal: false
    css: ["default", "default-fonts", "slides.css", "slides_copy.css"]
    lib_dir: libs
    nature:
      highlightStyle: rainbow
      highlightLines: true
      countIncrementalSlides: false
---
class:inverse middle center

```{r setup, include=FALSE}
options(htmltools.dir.version = FALSE)
knitr::opts_chunk$set(eval = FALSE)
```

```{r xaringan-extra, echo=FALSE, eval=TRUE}
#xaringanExtra::use_scribble()
#xaringanExtra::use_panelset()
#xaringanExtra::use_clipboard()
#xaringanExtra::use_search(show_icon = TRUE)
```

# *Week 11 - Python: Scientific computing*

----

# I (Tuesday)

<br> <br> <br> <br> <br>

### Jelmer Poelstra
### 2021/03/23 (updated: `r Sys.Date()`)

---

## Overview of this week

.pull-left[
**Tuesday's presentation**

- NumPy and SciPy (CSB 6.2)

]

.pull-right[
**Today's presentation:**

- Pandas (CSB 6.3)

- BioPython (CSB 6.4)
]

<br> <br>

---
class: center middle inverse

# Pandas (CSB 6.3)

-----

<br> <br> <br> <br>

---

## Pandas

Pandas is short for Python Data Analysis Library.
With its `Series` and especially `DataFrame`s,
you can do similar analyses to what is typically done in R using the *tidyverse*.

```python
import pandas as pd
import numpy as np
```

Like in R, we don't read files in line-by-line but load them all at once:

```python
import os
os.chdir('/fs/ess/PAS1855/users/<user>/CSB/scientific/sandbox')
# os.chdir('../CSB/scientific/sandbox')

data = pd.read_csv("../data/Dale2015_data.csv")
```

---

## Exploring DataFrames

- Show the first 6 rows with `head()`:

  ```python
  data.head()
  
  #>      Scientific_name	         English_name	          TipLabel	Female_plumage_score	Male_plumage_score
  #> 0	Abroscopus albogularis	  Rufous-faced Warbler	  Abroscopus_albogularis	45.833333	51.944444
  #> 1	Abroscopus schisticeps	  Black-faced Warbler	    Abroscopus_schisticeps	48.888889	47.777778
  #> 2	Abroscopus superciliaris	Yellow-bellied Warbler	  Abroscopus_superciliaris	43.194444	43.611111
  #> 3	Acanthagenys rufogularis	Spiny-cheeked Honeyeater	Acanthagenys_rufogularis	39.305556	39.166667
  #> 4	Acanthidops bairdii	     Peg-billed Finch	        Acanthidops_bairdii	40.555556	54.166667
  ```

- Just typing the name of the dataframe will also return a very useful view:

  ```python
  data
  ```
  
- Check the dimensions:

  ```python
  data.shape
  #> (5831, 5)
  ```

---

## Exploring DataFrames

- `columns` returns an `Index` object with the column names:

  ```python
  data.columns
  #> Index(['Scientific_name', 'English_name', 'TipLabel',
  #>        'Female_plumage_score', 'Male_plumage_score'],
  #>        dtype='object')
  ```
  
- `dtypes` returns data types by column &ndash; note, strings are called
  "object":

  ```python
  data.dtypes
  #> data_raw.dtypes
  #> Scientific_name          object
  #> English_name             object
  #> TipLabel                 object
  #> Female_plumage_score    float64
  #> Male_plumage_score      float64
  #> dtype: object
  ```

- A `DataFrame` has an explicit rowwise index: notice the rows numbering.
  
  ```python
  data.index
  #> RangeIndex(start=0, stop=5831, step=1)
  ```

---

## Manipulating DataFrames: renaming columns

- We can rename columns using `rename()` with a dictionary of old and new column
  names:
  
  ```python
  data = data.rename(columns={"Scientific_name": "latin",
                              "English_name": "english",
                              "Female_plumage_score": "score_f",
                              "Male_plumage_score": "score_m"})
  ```

---

## Manipulating DataFrames: adding columns

- Create a new column that sums the plumage score for males and females:

  ```python
  data["score_sum"] = data["score_f"] + data["score_m"]
  
  data.head()
  ```

- We could also easily add a column with a constant using a vectorized
  operation, like we have seen with NumPy:
  
  ```python
  data["Study"] = 1
  ```

- Or we could add a column of random numbers &ndash;
  note that we can get the number of rows on the fly using `data.shape[0]`:
  
  ```python
  data["Rnd"] = np.random.random(data.shape[0])
  ```

---

## Manipulating DataFrames: removing columns

- We can use `del()` to drop one column,
  or `drop()` to remove one or more columns:
  
  ```python
  del(data["score_sum"])
  
  data.drop(["Rnd", "Study"], axis = 1, inplace = True)
  ```
  
  - `axis = 0` acts along rows, and `axis = 1` along columns.
  - `inplace` means that the `DataFrame` is modified in place.

---

## Indexing DataFrames

- First, note that we can specify columns not just using `df["colname"]` but
  also using `df.colname`:
  
  ```python
  data["latin"]
  
  data.latin
  ```

- Next, we can index the resulting `Series` (1-dimensional array) like we
  may expect:
  
  ```python
  data["latin"][:3]
  #> 0 Abroscopus albogularis
  #> 1 Abroscopus schisticeps
  #> 2 Abroscopus superciliaris
  
  data.latin[:3]
  #> 0 Abroscopus albogularis
  #> 1 Abroscopus schisticeps
  #> 2 Abroscopus superciliaris
  ```

---

## Indexing DataFrames (cont.)

- But we can't index the entire `DataFrame` the way we may expect to:

  ```python
  data[0:3, 0:3]
  #> TypeError: '(slice(0, 3, None), slice(0, 3, None))' is an invalid key
  ```

- Instead we need to use the method `iloc()`:
  
  ```python
  data.iloc[2, 1]
  #> 'Yellow-bellied Warbler'
  
  # First 2 rows, all columns (out-of-range slices work):
  data.iloc[:2, :10]
  
  # First 2 rows, columns 2 and 4:
  data.iloc[:2, [1, 3]]
  
  # Last 5 rows, all columns:
  data.iloc[-5:, ]
  ```
  
---

## Indexing DataFrames (cont.)

We can also use `loc`, which selects rows and columns using **labels**.  

The labels for the columns are of course the column names,
and the labels for the rows is the index (row numbers).

Notice that ranges given with `loc` are *inclusive*,
so `data.loc[:3, ]` returns the first *four* rows!

```python
data.loc[:3, ["latin", "english"]]
#> 0 Abroscopus albogularis   Rufous-faced Warbler
#> 1 Abroscopus schisticeps   Black-faced Warbler
#> 2 Abroscopus superciliaris Yellow-bellied Warbler
#> 3 Acanthagenys rufogularis Spiny-cheeked Honeyeater
```

---

## Indexing / filtering DataFrames

- We can also index based on (a `Series` of) Booleans,
  for instance to select the row(s) for a certain species:

  ```python
  data.latin == "Zosterops mouroniensis"
  #> 0       False
  #> 1       False
  #> 2       False
  #> ...
  
  data.loc[data.latin == "Zosterops mouroniensis"]
  #         Scientific_name	       English_name	            TipLabel	Female_plumage_score	Male_plumage_score	Sum_scores	Study
  # 5801	Zosterops mouroniensis	Mount Karthala White-eye	Zosterops_mouroniensis	47.916667	47.5	95.416667	1
  ```

- Or get only the most highly dimorphic species:

  ```python
  data[(data.score_m > 70) & (data.score_f < 40)]
  #> 	      latin	              english	TipLabel	      score_f	score_m
#> 875	   Chiroxiphia pareola	Blue-backed Manakin	     Chiroxiphia_pareola	39.305556	71.666667
#> 1355	  Cyornis hainanus	   Hainan Blue-flycatcher	  Cyornis_hainanus	37.222222	71.250000
#> 1811	  Euplectes hartlaubi	Marsh Widowbird	         Euplectes_hartlaubi	39.583333	70.555556
#> 1885	  Foudia omissa	      Forest Fody	             Foudia_omissa	37.777778	71.805556
  ```

---

<figure>
<p align="center">
<img src=img/Blue-backedManakin.jpeg width="62%">
<figcaption>Blue-backed Manakin - males (<a href="http://www.arctracer.com/photos/trinidad/birds/Blue-backedManakin.html">Figure source</a>)</figcaption>
</p>
</figure>

<figure>
<p align="center">
<img src=img/manakin_female.jpg width="62%">
<figcaption>Blue-backed Manakin - female (<a href="http://www.arthurgrosset.com/sabirds/photos/chipar28910.jpg">Figure source</a>)</figcaption>
</p>
</figure>

---

<figure>
<p align="center">
<img src=img/marsh_widowbird.jpg width="60%">
<figcaption>Marsh Widowbird - male (<a href="http://www.arthurgrosset.com/sabirds/photos/chipar28910.jpg">Figure source</a>)</figcaption>
</p>
</figure>

<figure>
<p align="center">
<img src=img/marsh_widowbird_female.jpg width="60%">
<figcaption>Marsh Widowbird - female (<a href="http://www.arthurgrosset.com/sabirds/photos/chipar28910.jpg">Figure source</a>)</figcaption>
</p>
</figure>

---

## Indexing / filtering DataFrames

- We can even select rows based on only part of the cell content,
  using `str.contains()`:

  ```python
  data[data.english.str.contains("Bower")]
  #> [All rows containing "Bower" in the "english" column]
  
  data[data.english.str.contains("Bower")]["latin"][:3]
  #> 188 Amblyornis flavifrons
  #> 189 Amblyornis inornata
  #> 190 Amblyornis macgregoriae
  #> Name: Scientific_name, dtype: object
  ```

<br>

--

.content-box-diy[
Try this:

```python
data[data.english.str.contains("Bower")].loc[:2, "latin"]
```

Why is it not returning any rows?
]

---

## Views versus copies

When we slice and filter `DataFrames`, we generally get a "**view**" of the
data, as opposed to a *copy* of the data.
Therefore, we get a warning when we try to modify such as view:

```python
high_male_score = data[data["score_m"] > 65]

high_male_score["score_qual"] = "High"
#> [...] SettingWithCopyWarning:
#> A value is trying to be set on a copy of a slice from a DataFrame.
```

Our operation still worked &ndash;
a column has been added to `high_male_score` but not to data:

```python
high_male_score.columns
#>Index(['latin', 'english', 'TipLabel', 'score_f', 'score_m', 'score_qual'],
#>      dtype='object')

data.columns
#> Index(['latin', 'english', 'TipLabel', 'score_f', 'score_m'],
#>       dtype='object')
```

---

## Copy and modify

But in such case, we should instead make a copy of the data:

```python
high_male_score = data[data["score_m"] > 65].copy()

high_male_score["score_qual"] = "High"
```

---

## Summary statistics

Like we have seen with NumPy, we can also easily get summary statistics:

```python
data.score_m.mean()
#> 51.009189390042877

data.score_m.median()
#> 49.72222222

data.score_m.std()
#> 8.2006629346736908
```

---

## Some simple plots with Matplotlib &ndash; histogram:

```python
data.score_m.hist()
```

<p align="center">
<img src=img/hist.svg width="90%">
</p>

---

## Simple plots with Matplotlib &ndash; scatterplot

```python
data.plot.scatter(x = "score_m", y = "score_f")
```

<p align="center">
<img src=img/scatter.svg width="90%">
</p>

---

## Simple plots with Matplotlib &ndash; boxplot:

```python
data[["score_m", "score_f"]].plot.box()
```

<p align="center">
<img src=img/boxplot.svg width="90%">
</p>

---

## Intermezzo

Get the English names of species for which both males and females have a
plumage score higher than XX.

---

## Intermezzo: Solutions


---
class: center middle inverse

# BioPython (CSB 6.4)

-----

# I: Retrieving sequences from NCBI (6.4.1)

<br> <br> <br> <br>

---

## Using BioPython to inferface with NCBI databases

While we already downloaded some data from NCBI manually in the exercises for
week 7 (Bioinformatics Data),
we can also use NCBI's **"Entrez Programming Utilities"** to do this
programmatically.

BioPython includes an Entrez module that interfaces with NCBI Entrez. 
This is a much better method to find and download data, if you regularly need
to do so.

- We start by importing the module:
  
  ```python
  from Bio import Entrez
  ```

- As another setup step,
  we should provide our e-mail address to let NCBI know who we are:

  ```python
  Entrez.email = "me.1@osu.edu"  # Replace by your email address
  ```

---

## Search the database

- Create a "handle" to search results:

  ```python
  handle = Entrez.esearch(db = "nuccore",
                          term = ("Uropsilus investigator[Organism]"),
                          RetMax = 200)
  ```

- Read the results and close the handle:

  ```python
  search_results = Entrez.read(handle)
  handle.close()
  ```

<br>

- Our results are returned in the form of a dictionary,
  so let's look at the keys:
  
  ```python
  search_results.keys()
  #> dict_keys(['Count', 'RetMax', 'RetStart', 'IdList',
  #>            'TranslationSet', 'TranslationStack',
  #>             'QueryTranslation'])
  ```
  
---

## Looking at the results

- How many sequences did we find?  
  
  ```python
  search_results["Count"]
  '126'   # Has increased from '71' in the book!
  ```
  
- What is the list of GenBank identifiers?

  ```python
  id_list = search_results["IdList"]
  print(id_list)
  #> ['524853022', '555947199', '555947198', ... , '555946814']
  ```

- Did we get all 126 IDs in the list? Note that the default is to only return
  20, but because we used `RetMax = 200` in the call to `Entrez.esearch()`,
  we got all of them:

  ```python
  len(id_list)
  #> '126'
  search_results["RetMax"]
  #> '200'
  ```

---

## Downloading the sequences

We'll now use the GenBank IDs to actually download some sequences:

```python
search_handle = Entrez.efetch(db = "nuccore",
                              rettype = "fasta",
                              retmode = "text",
                              id = id_list)

# Set up a handle to an output file:
out_handle = open("Uropsilus_seq.fasta", "w")

# Write the obtained sequence data to the output file:
for line in handle:
    out_handle.write(line)

# Close the handles:
out_handle.close()
search_handle.close()
```

Next, we'll read in our FASTA file using SeqIO.

---

class: center middle inverse

# BioPython (CSB 6.4)

-----

# II: Input and output of sequence data using *SeqIO* (6.4.2)

<br> <br> <br> <br>

---

## Reading a FASTA file with SeqIO

- We start by importing the SeqIO module:

  ```python
  from Bio import SeqIO
  ```

- Let's print the ID and sequence length for each sequence:

  ```python
  in_handle = open("Uropsilus_seq.fasta", "r")
  
  for record in SeqIO.parse(in_handle, "fasta"):
      print(record.description)
      print(len(record), '\n')
  in_handle.close()
  
  #> KC516837.1 Uropsilus investigator isolate A11 apolipoprotein B (ApoB) gene, partial cds
  #> 573 
  
  #> KC516819.1 Uropsilus investigator voucher mlxs331 cytochrome c oxidase subunit I (COI) gene, partial cds, alternatively spliced; mitochondrial
  #> 912 
  
  #> KC516818.1 Uropsilus investigator voucher mlxs022 cytochrome c oxidase subunit I (COI) gene, partial cds, alternatively spliced; mitochondrial
  #> 912 
  #> [...]
  ```

---

## Selecting only sequences for the BMI1 genes

```python
# We will import the "re" module for regular expression searches:
import re

output_handle = open("Uropsilus_BMI1.fasta", "w")

for record in SeqIO.parse("Uropsilus_seq.fasta", "fasta"):
    
    # Find the BMI1 sequences using "re.search"
    if re.search("BMI1", record.description):
        print(record.id)
        short_seq = record[:100]  # Just take the first 100 bases
        SeqIO.write(short_seq, output_handle, "fasta")
        
output_handle.close()
```

---

class: center middle inverse

# BioPython (CSB 6.4)

-----

# III: Programmatic BLAST Search (6.4.3)

<br> <br> <br> <br>

---

## BLAST

The Basic Local Alignment Search Tool (BLAST) finds regions of similarity
between biological sequences. Biopython provides a module to conveniently
run a BLAST search against online databases:

```python
# NCBIWWW allows programmatic access to NCBI's BLAST server
from Bio.Blast import NCBIWWW
# retrieve sequences using SeqIO
handle = open("Uropsilus_BMI1.fasta", "r")
# convert SecRecord into a list for easy access
records = list(SeqIO.parse(handle, "fasta"))
# retrieve fourth sequence
print(records[3].id, " ", records[3].seq)
```

---

## BLAST

We are ready to run our BLAST search against the NCBI nucleotide
database (other options are blastp , blastx , tblastn , and tblastx ):

```python
# always tell NCBI who you are
Entrez.email = "me@bigu.edu"
# NCBIWWW.qplast requires three arguments:
# program, database, sequence
result_handle = NCBIWWW.qblast("blastn", "nt", records[3].seq)
# set up output file
save_file = open("my_blast.xml", "w")
# write results to output file
save_file.write(result_handle.read())
save_file.close()
result_handle.close()
```

---

## BLAST

By default, the BLAST query returns an XML file that we parse using the
NCBIXML parser:

```python
from Bio.Blast import NCBIXML
result_handle = open("my_blast.xml")
# use NCBIXML.read if you run BLAST for one sequence
# or NCBIXML.parse for multiple sequences
blast_records = NCBIXML.read(result_handle)
```

---

## BLAST

Next, we loop through the individual alignment hits and retrieve some
basic information about results that have a good match (i.e., low E value)
to our Uropsilus BMI1 query sequence and are more than 3000 nucleotides
long:

```python
E_VALUE_THRESH = 0.04
for alignment in blast_records.alignments:
for hsp in alignment.hsps:
if hsp.expect < E_VALUE_THRESH and alignment.length > 3000:
print("****Alignment****")
print("sequence:", alignment.title)
print("length:", alignment.length)
print("E value:", hsp.expect)
print(hsp.query[0:75] + "...")
print(hsp.match[0:75] + "...")
print(hsp.sbjct[0:75] + "...")
#> ****Alignment****
#> sequence: gi|1304911126|ref|XM_006933246.4| PREDICTED: Felis catus BMI1 proto-oncogene, polycomb ring finger (BMI1), transcript variant X3, mRNA
#> length: 3523
#> E value: 2.25861e-42
#> TATTATGCTGTTTTGTGAACCTGTAGAAAACAAGTGCTTTTTATC...
#> |||||||||||||||||||||||||||||||||||||||||||||...
#> TATTATGCTGTTTTGTGAACCTGTAGAAAACAAGTGCTTTTTATC...
#> [...]
```


class: center middle inverse

# BioPython (CSB 6.4)

-----

# IV: Querying PubMed for scientific literature information (6.4.4)

<br> <br> <br> <br>

---

## PubMed search


---
class: center middle inverse

# Questions?

-----

<br> <br> <br> <br>

