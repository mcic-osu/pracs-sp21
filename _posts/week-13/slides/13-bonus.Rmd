---
class:inverse middle center

# Advanced Snakemake

----

.left[
- #### Configuration files
- #### Using programs where you don't specify output files
- #### "Target rules may not contain wildcards"
- #### Referring to wildcards in actions
- #### Forcing reruns based on changes in input files or code
- #### Miscellaneous
]

---

## Configuration files

*Configuration files* can be a good place to store settings for your workflow
that you want to be able to vary easily and transparently,
or that you just want to state very clearly.

In your Snakefile, you can include a `configfile` directive
(for the entire workflow, not for individual rules) that points to a YAML or
JSON file with these configurations.

Then, all key-value pairs from the config file will loaded into a dictionary
called `config` that you can call in your Snakefile &ndash; for example:

```sh
# CONFIG FILE:
min_qual: 30
```

```python
# SNAKEFILE:
config["min_qual"]   # Get the value for `min_qual`
```

---

## Example usage of a configuration file

In a file called `config.yaml`:

```sh
out_dir: path/to/output/
min_qual: 30
```

In the Snakefile:

```python
# ...
configfile: "config.yaml"

OUT_DIR=config["output_dir"]

# ..

rule filter_bam:
    input: ...
    output: os.path.join(OUT_DIR, "{sample}_{read}.fastqc.html")
    shell: 'filter_bam.sh -q config["min_qual"] {input} > {output}'
```

Note that we assigned `output_dir` to a variable in the Snakefile,
and used `min_qual` directly &ndash; either is possible.

---

## Using programs where you don't specify output files

For fairly many programs, you don't explicitly define the names of output files,
but the program will just output files with names similar to the input file names.

For instance, when we run FastQC:

```sh
fastqc -o results/fastqc sampleA_R1.fastq.gz
```

We are only specifying an output dir, and FastQC will put output files in there:

```sh
ls my_outdir
#> sampleA_R1.fastqc.html sampleA_R1.fastqc.zip
```

**How do we create a rule for such programs?**

---

## Using programs where you don't specify output files

Should we just omit the output, since we don't need to define it anyway?

```python
rule fastqc:
    input: data/{sample}.fastq.gz
    shell: "fastqc -o results/fastqc"
```

--

.content-box-q[
What would be some problems with this approach?
]

--

Because Snakemake works backwards, that is, it figures out what it needs to do
in order to produce the files mentioned in `input` and `output`:

- It will never see a reason to run the current `rule fastqc`
  (though we could still run it using `snakemake -j fastqc`).

- If a next step depends on the output of FastQC (like MultiQC does),
  Snakemake cannot make this connection:
  remember, **relationships between rules are *inferred* by Snakemake**,
  not stated explicitly.

- Snakemake can't fully check if the rule ran successfully!

---

## Using programs where you don't specify output files

Instead, we should still use an `output` directive:
even though the value is not used by the command itself,
it will be used by Snakemake to infer relationships between rules and to check
whether the rule ran successfully:

```python
rule fastqc:
    input: data/{sample}.fastq.gz
    output:
        "{sample}_R1.fastqc.html",
        "{sampleA}_R1.fastqc.zip"
    shell: "fastqc -o results/fastqc"
```

In such cases, it's not necessarily critical to specify all (possible) output
files, just the ones deemed necessary for the purposes mentioned above.

--

.content-box-info[
Alternatively, you can specify a **directory** rather than files as the output.
This may make sense if the names of the output files are unpredictable or
otherwise unknown.
But this only makes sense if each sample has its own output directory!

```python
output: directory("results/fastqc/{sample}")
```
]

---

## "Target rules may not contain wildcards"

What if we now just want to run the rule `count_words`?

```sh
snakemake -j1 count_words
#> WorkflowError:
#> Target rules may not contain wildcards. Please specify concrete files or a rule without wildcards.
```

The problem here is that ...

Note that this is also a common error to get when building your workflows and
wanting to run the entire thing.

---

## "Target rules may not contain wildcards"

If we did want to **run just this specific rule with wildcards**, we could:

- Specify one or more specific output files:

```sh
snakemake -j1 res/bookA_cnt.txt
snakemake -j1 res/bookB_cnt.txt res/bookC_cnt.txt
```

- Create a rule that triggers execution of our target rule by listing all its
  output files:

```sh
rule trigger_count_words:
    input: expand("res/{book}_cnt.txt", book=BOOKS)
```        

---

## Referring to wildcards in actions

Sometimes you need to **refer to a sample ID in your action** rather than an
input file name &ndash;
say our script needs an input dir and sample/book ID like so:

```sh
scipts/count_words.py -d <input_dir> -i <book_id>
```

Our rule currently looks like this:

```python
rule count_words:
    input: "data/{book}.txt",
    output: "res/{book}_cnt.txt"
    shell: "scripts/count_words.py {input} > {output}"
```

**How can we change the `shell` directive to use the book ID wilcard?**

---

## Referring to wildcards in actions

**How can we change the `shell` directive to use the book ID wilcard?**

```python
# THIS WON'T WORK:
# shell: "scripts/count_words.py -d res -o {book} > {output}"
```

```python
# YES -- use "{wildcards.<wildcard-name>}":
shell: "scripts/count_words.py -d res -o {wildcards.book} > {output}"
```

Why do we need `{wildcards.book}` and not just `{book}` akin to how we refer to
`{input}`?

--

Even though both are variable-like references with `{}`,
only `{book}` is a **wildcard**,
which has not been explicitly defined, and is left for Snakemake to figure out.

Snakemake figures this out in `{input}` and `{output}` directives *only*,
and if we want to refer to them elsewhere,
we need to use `{wildcards.<wildcard-name>}`.

---

## Forcing reruns based on changes in input files or code

https://snakemake.readthedocs.io/en/stable/project_info/faq.html#snakemake-does-not-trigger-re-runs-if-i-add-additional-input-files-what-can-i-do

```sh
snakemake -R $(snakemake --list-input-changes)  # Force re-run if samples have been added
snakemake -n -R $(snakemake --list-params-changes) # Force re-run if params have been updated
snakemake -n -R $(snakemake --list-code-changes) # Force re-run if code has been updated
```

---

## `params`

---

## Miscellaneous

### Call separate Snakefiles for parts of the workflow

If your workflow is pretty big, it can be useful to split it up across multiple
Snakefiles. You can make rules in another Snakefile available as follows:

```python
include rules/qc_rules.smk
```

### Mark files as protected (no write permissions)

```python
output: protected("sorted_reads/{sample}.bam") 
```

### Mark files as temporary (to be deleted)

```python
output: temp("mapped/{sample}.bam")
```

---

## Miscellaneous (cont.)

### Use a "token" file if a rule has no unique output

(e.g. only modifies a file) -- and `touch` in the rule's action:

```python
rule token_example:
    input:  'some_file.txt'
    output: 'some_file.tkn'
    shell: "some_command --do-things {input} && touch {output}"
```

### Visualize rules, not jobs

```python
snakemake --rulegraph | dot -Tsvg > rules.svg
```

---

## Calling Python or R scripts directly, without arguments

```python
# NOTE: when calling scripts, "snakemake.input" etc is available automatically:
script: pythonscript.py
    quals = [rec.qual for record in VarFile(snakemake.input[0])]
script: rscript.R
    snakemake@input[["myfile"]]                 # In R, S4 object will be available
```


