---
title: "Week 2 - Part II - Managing Files in the Shell"
output:
  xaringan::moon_reader:
    seal: false
    css: ["default", "default-fonts", "slides.css"]
    lib_dir: libs
    nature:
      highlightStyle: rainbow
      highlightLines: true
      countIncrementalSlides: false
---
class:inverse middle center

```{r setup, include=FALSE}
options(htmltools.dir.version = FALSE)

knitr::opts_chunk$set(eval = FALSE)
```

## *Week 2: <br> Project Organization and Markdown*
----
# Part II: Managing Files in the Shell

<br> <br> <br> <br> <br>

### Jelmer Poelstra
### 2021/01/19 (updated: `r Sys.Date()`)

---
class: center middle inverse

# Overview

----

.pull-left[
### [VS Code setup](#osc-vscode)
### [Wildcard expansion](#wildcard)
### [Brace expansion](#brace)
]
.pull-right[
### [File permissions](#permissions)
### [File renaming](#file-renaming)
]

---
name:osc-vscode

## Starting *VS Code* at OSC

1. Go to <https://ondemand.osc.edu> in your browser, and log in.

2. Click on `Interactive Apps` in the blue top bar.

3. Near the bottom, click `Code Server`.

4. In the form:
   - Under `Number of hours`, select 1 or 2 hours.
   - Under `Working directory`, type `/fs/ess/PAS1855`.

5. Click the blue `Launch` button, and you'll move to a different page.

5. Once the top bar of the box is green, and click `Connect to VS Code`.

<p align="center">
<img src=img/w01/osc-code-launch.png width="55%">
</p>

---

## Getting VS Code ready

**We need to start with a bit of housekeeping:**

1. Gain screen real estate by toggling off the Side Bar by pressing `Ctrl+B`.

2. Open a Terminal by pressing <kbd>Ctrl</kbd>+<kbd>backtick</kbd> or
   <kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>C</kbd>.
  
3. Close the "Welcome" tab (click the `X`) and pull up the terminal's dividing
   line to the top of your window.

4. In the terminal, the prompt says `Singularity>`. This means we are inside a
   Singularity container. **Type `bash` to exit the container.**

Finally, we're ready to go...

## TO DO: START TEXT DOCUMENT

<br>

--

.content-box-warning[
In *VS Code*, there are default existing bindings for the
<kbd>Ctrl</kbd>+<kbd>K</kbd> (*cut to end of line*) and 
<kbd>Ctrl</kbd>+<kbd>E</kbd> (*go to end of line*) combinations,
so they won't be interpreted by the shell.
If you have an <kbd>end</kbd> key, that will also work to move to the end of
the line.
]

---

## Create a dummy project &ndash; following Buffalo

- Go to your starting point dir:
  ```sh
  cd /fs/ess/PAS1855/users/$USER
  ```
  
- Create the directory structure:

  ```sh
  $ mkdir zmays-snps
  $ cd zmays-snps
  $ mkdir -p data/seqs scripts analysis
  ```

--

- Create some empty "sequence files":
  ```sh
  $ cd data/seqs
  $ touch sample1_F.fastq.gz sample1_R.fastq.gz \
        sample2_F.fastq.gz sample2_R.fastq.gz \
        sample3_F.fastq.gz sample3_R.fastq.gz
  ```

--

- For a nice overview of your directory structure:

  ```sh
  tree
  ```

---

## Shell expansion I: Wildcard expansion

|Wildcard | Matches |
|-|-|
| * | Any number of any character, including nothing |
| ? | Any single character 
| [] and [^] | One or none (`^`) of the "character set" within the brackets   

--

- With the following files in a directory:
  ```sh
  # sample1_F.fastq.gz sample1_R.fastq.gz
  # sample2_F.fastq.gz sample2_R.fastq.gz
  # sample3_F.fastq.gz sample3_R.fastq.gz
  ```

--

- **To match both "*sample1*" files:**
  ```sh
  ls sample1_?.fastq.gz
  ls sample1*
  ls sample1*fastq.gz
  ```

---

## Shell expansion I: Wildcard expansion (cont.)

|Wildcard | Matches |
|-|-|
| * | Any number of any character, including nothing |
| ? | Any single character 
| [] and [^] | One or none (`^`) of the "character set" within the brackets   

- With the following files in a directory:
  ```sh
  # sample1_F.fastq.gz sample1_R.fastq.gz
  # sample2_F.fastq.gz sample2_R.fastq.gz
  # sample3_F.fastq.gz sample3_R.fastq.gz
  ```

- **To match only files with forward (*"F"*) reads:**
  ```sh
  $ ls *F*
  $ ls *F.fastq.gz
  ```

---

## Shell expansion I: Wildcard expansion (cont.)

|Wildcard | Matches |
|---------|---------|
| * | Any number of any character, including nothing |
| ? | Any single character 
| [] and [^] | One or none (`^`) of the "character set" within the brackets   

- With the following files in a directory:
  ```sh
  # sample1_F.fastq.gz sample1_R.fastq.gz
  # sample2_F.fastq.gz sample2_R.fastq.gz
  # sample3_F.fastq.gz sample3_R.fastq.gz
  ```

- **To match files for sample1 and sample2 only using a character class:**
  ```sh
  $ ls sample[12]*   # Use the character class notation
  $ ls sample[1-2]*  # Can use ranges like [0-9], [A-Z], [a-z].
  $ ls sample[^3]*   # Other way around: exclude sample3
  ```

--

  .content-box-warning[
  `[]` works on character ranges only: 0-9 works; 10-13 does not.
  ]

---

## Shell expansion I: Wildcard expansion (cont.)

- Wildcards are only used to match (or *expand to*) file names.  
  (This process is also called *"globbing"*.)
  
- Why do we call this a type of _**shell** expansion_?

--

  - The expansion &ndash;to all matching file names&ndash; is done *by the shell*,   
    **not** by `ls` (or other commands you might be using wildcards with).

  - That is, `ls` will see the list of files after the expansion.

--

<br>

- When using shell expansion to *move* or *delete* files,
  it is useful to first check what your command will "see",
  using `ls` or `echo`:
  
  ```sh
  echo sample[12]*
  ```
--

.content-box-info[
Examples so far may seem trivial but you can use these techniques to easily pull out files among 100s or 1000s of files.
]

---

## Shell expansion I: Wildcard expansion (cont.)

- **Don't confuse wildcards with regular expressions!**

  - What do **`*`** and **`?`** mean in regular expressions?

<br>

- Regular expressions are useful across the board in programming,  
  and we will have a Python module devoted to them (week 11).

---

## Shell expansion II: Brace expansion

- *Wildcard expansion* looks for corresponding files
    and expands to whichever files are present:
    can't be used to create files or dirs.

- **_Brace expansion_**, on the other hand, expands to whatever you tell it to.  

<br>

- Use `..` to indicate ranges:
  ```sh
  $ mkdir -p data/obs_2021-01-{01..31} # Numeric range works!
  
  $ touch plot-{A..F}                  # Character range works
  ```

- Use a comma-separated list:
  ```sh
  $ mkdir -p fig-{small,medium,large}-{color,grayscale}
  ```

---

## Shell expansion II: Brace expansion

- *Wildcard expansion* looks for corresponding files
    and expands to whichever files are present:
    can't be used to create files or dirs.

- **_Brace expansion_**, on the other hand, expands to whatever you tell it to.  

.content-box-q[
What will happen in these two case?
  
  ```sh
  $ # touch plot-{A..F}
  
  $ ls plot-[A-G]
  
  $ ls plot-{A..G}
  ```
]

---

## Shell expansion II: Brace expansion

- *Wildcard expansion* looks for corresponding files
    and expands to whichever files are present:
    can't be used to create files or dirs.

- **_Brace expansion_**, on the other hand, expands to whatever you tell it to.  
  
.content-box-answer[
- Wildcard expansion will ignore the missing "*plot-G*":
```sh
$ ls plot-[A-G]
# plot-A  plot-B  plot-C  plot-D  plot-E  plot-F
```

- Brace expansion will complain about the missing "*plot-G*":
```sh
$ ls plot-{A..G}
# ls: cannot access 'plot-G': No such file or directory
# plot-A  plot-B  plot-C  plot-D  plot-E  plot-F
```
]

---
background-color:#e4ede4

## `r icon::fa("user-edit")` Your turn: File matching

1. Create a dir `week02/sandbox/` and move into it.

2. Using *brace expansion* and the **`touch`** command,
  create empty `R1` and `R2` fastq files for 100 samples with IDs from `001`
  to `100`: `sample<ID>_R1_001.fastq` and `sample<ID>_R2_001.fastq`.

3. Using *wildcard matching* and by piping **`ls`** output into **`wc -l`**,
  count the number of "`R1`" files (forward reads).

4. **_Bonus:_** Copy all files *except the two for "`sample100`"* into a new
  directory called `selection` &mdash;
  use a wildcard to do the move with a single command.
  (But you'll need to create the new dir first.)

---
background-color:#e4ede4

## Solutions: File matching

1. Create a dir `week02/sandbox/` and move into it:
```sh
mkdir week02/sandbox/
cd week02/sandbox/     # Use the Alt+. shortcut after `cd`
```

2. Create empty `R1` and `R2` fastq files for 100 samples:
```sh
touch sample{001..100}_R{1,2}_001.fastq
```

3. Count the number of `R1` files:
```sh
ls sample*R1*fastq | wc -l
ls *R1* | wc -l # This works but it's better to be restrictive
```

4. **_Bonus:_** Copy all files except "`sample100`" into a new dir called `selection`:
```sh
mkdir selection
mv sample[^1]* selection/
```

---

## Shell expansion III: Command substitution

- *Command substitution* allows you to store and pass the output of a command
  (or pipeline of commands) to another command.
  
  These two examples show how that can be useful and why a pipe wouldn't work:
  ```sh
  echo "There are $(wc -l data.csv) lines in my data file."
  # There are 87 lines in my data file.
    
  mkdir results_$(date +%F)
  # results_2021-01-05
  ```

## TODO: ADD A FILE

---

## Shell expansion III: Command substitution (cont.)

- We can also save a result in a *variable* or *array*:
  ```sh
  n_treatments=$(cut -f 2 data.csv | sort | uniq)
  echo ${n_treatments}   # Shorthand: "$n_treatments"
  
  treatments=$(cut -f 2 data.csv)
  echo ${treatments[@]}
  ```

---

## Special characters and escaping them

We've seen that the wildcards **`*`** and **`?`** have a special meaning.  

What if we had unwieldy file names,
and needed to match a *literal* **`*`** or **`?`**

--

- A **backslash** ("**`\`**") can be used to "escape" the special meaning
  of the character following the backslash:
  e.g. "**`\*`**" to match a literal "**`*`**".
  
  ```sh
  rm my\ bad\*file  # Tab autocomplete will work and insert \'s
  ```

--

- **Quoting** a string of characters will also escape special meaning
  of characters within them, with single quotes (**`'...'`**) being more severe
  than double quotes (**`"..."`**) &mdash; more on this later. 

  ```sh
  rm 'my bad*file'
  ```

--

.content-box-info[
Backslashes can also *assign* special meaning
&ndash; most common are **`\t`** (tab) and **`\n`** (newline).
We'll talk more about these *regular expressions* later.
]

  
---
class: inverse middle center

# Treating data as read-only:
# Viewing and modifying file permissions
----
<br><br><br>

---

## Showing file permissions

- To show file permissions, use **`ls`**  with the **`-l`** (*long* format)
  option.shows file permissions.
  
  (The command below also uses the **`-a`** option to show all files,
  including hidden ones, and **`-h`** shows file sizes in "human-readable"
  format.)

<p align="center">
<img src=img/w02/long-ls.png width="600">
</p>

---

## File permissions (cont.)

.pull-left[
<p align="left">
<img src=img/w02/permissions.png width="300">
</p>
]

.pull-right[
.content-box-info[
Generally, it is prudent to not give "others" write permissions.
]
]

--

- Can be changed in several ways with the `chmod` command:
  
  - `chmod <who>=<set-permission>`
  
  - `chmod <who>+<add-permission>`
  
  - Digits: 4 for read, 2 for write, 1 for execute &ndash; e.g. 7 => all three.
  
  ```sh
  chmod u=rwx my-program     # user=read-write-execute
  chmod u=rw,go=r my-file    # user=read-write, group&others=read 
  chmod a=r data/raw/*       # all=read
  chmod -R 744               # user: rwx, group&others: read
  ```

---

## File permissions (cont.)

.pull-left[
<p align="left">
<img src=img/w02/permissions.png width="300">
</p>
]

.pull-right[
.content-box-info[
Generally, it is prudent to not give "others" write permissions.
]
]

- Can be changed in several ways with the `chmod` command:
  
  - `chmod <who>=<set-permission>`
  
  - `chmod <who>+<add-permission>`
  
  - Digits: 4 for read, 2 for write, 1 for execute &ndash; e.g. 7 => all three.
  
- **To make your raw data read-only:**
  ```sh
  chmod u-w data/raw/*       # Take away write permission
  
  chmod 400 data/raw/*       # User: read, group & others: none
  ```

---

## Add -x necessary for dirs

---

## File permissions: Practice

- First, let's look at the original permissions of the files:
  ```sh
  cd week02/sandbox
  ls -l selection/
  ```

- Then, limit permissions for **a**ll to **r**ead, and check what we did:
  ```sh
  chmod a=r selection/
  ls -l selection/
  ```
--

- What happens when we try to remove write-protected files?
  ```sh
  rm selection/*
  
  rm -f selection/*  # Be careful with `rm -f`
  ```

.content-box-info[
While *you* (the file owner) can still remove write-protected files,
others really can't read/write/execute files without appropriate permissions.
]

---

## Sidenote: "The Unix Chainsaw"

- What will these two commands do?
  ```sh
  rm -rf tmp-data/aligned-reads*
  
  rm -rf tmp-data/aligned-reads *
  ```

<br>

--

- What are we removing with the last command?
  ```sh
  mkdir "raw sequences"
  mkdir sequences
  rm -rf raw sequences
  ```

---

## Programmatically renaming files

- Many different ways to do this in the shell,
  admittedly none as easy as one might have hoped for.
  
- Here, we'll use the `basename` command and a `for` loop.

- `basename` strips any dir name that may be present from a file name (path),
  and optionally, removes a suffix:
  ```sh
  basename selection/sample001_R1_001.fastq
  # sample001_R1_001.fastq
  
  basename selection/sample001_R1_001.fastq _001.fastq
  # sample001_R1
  ```

---

## Programmatically renaming files (cont.) 
  
- `for` loops are a verbose method for tasks like renaming,  
  but are intuitive and good practice.
  
  The following shows the basic syntax of a for loop,
  and how the variable that is looped over is *assigned* to `oldname`,
  but *recalled* as `${oldname}`:

  ```sh
  for oldname in *.fastq
  do
     echo "Old name: ${oldname}"
  done
  ```

--

.content-box-info[
Note how we are using *globbing* (wildcard file name matching)
to define what will be looped over.
]

---

## Programmatically renaming files (cont.) 
  
- `for` loops are a verbose way for tasks like renaming,  
  but are intuitive and good practice.
  
  Next, we assign a new name for each file, and **`echo`** the names as  
  a sanity check:
  
  ```sh
  for oldname in *.fastq
  do
     newname=$(basename $oldname _001.fastq).fq
     echo "Old/new name: $oldname $newname"
  done
  ```

---

## Programmatically renaming files (cont.) 
  
- `for` loops are a verbose way for tasks like renaming,  
  but are intuitive and good practice.
  
  Finally, we add the actual **`mv`** command:  

  ```sh
  for oldname in *.fastq
  do
     newname=$(basename $oldname _001.fastq).fq
     echo "Old/new name: $oldname $newname"
     mv $oldname $newname
  done
  ```

---

## Creating symbolic links

- Use absolute path for the source

```sh
ln -s -t scripts/ ~/scripts/*
ln -s -t data/ref/ ~/data/ref/refgenome.fa
```

- Practice: create a symbolic link to the project dir from your home dir

---
class: inverse middle center

# Questions?

----

<br> <br> <br> <br>

---
class: inverse middle center
name: bonus

# Bonus Materials

----

<br>

### [More conditional file processing](#conditional)
### [Standard error](#stderr)
### [Other tricks from Buffalo Ch. 3](#tricks)

---
background-color: #ededed
name:conditional

## Bonus: More conditional file processing

Remove all empty files in a directory:

```sh
for i in *
do
   if [ ! -s $i ]
   then
      echo rm $i
   fi
done
```

<br>

--

Code similar to the above can be applied to many tasks,  
though this task can be achieved much more concisely using `find`:

```sh
find . -size 0 -delete
```

---
background-color: #ededed
name: stderr

## Standard Error

- When commands run into errors, they will print error messages.  
  
  Error messages are **not** part of standard out,   
  and instead represent a separate output stream: **"standard error"**.

--

- We can see this when we try to list a non-existing directory:
  ```sh
  ls -lhr solutions/ > solution_files.txt 
  # ls: cannot access solutions.txt: No such file or directory
  ```

- The error was printed to screen. What about the file?

--

  ```sh
  $ ls
  # solution_files.txt
  $ cat solution_files.txt
  $                # We just get our prompt back - file is empty
  ```

---
background-color: #ededed

## Standard error (cont.)

- So, without redirection **(a)** versus with **`>`** redirection **(b)**:
<p align="left">
<img src=img/w01/std-streams.png width="550">
</p>

<br>
--

- But we *can* also redirect the standard error:
  ```sh
  ls -lhr solutions/ > solution_files.txt 2> errors.txt
  ls -lhr solutions/ &> out.txt # `&>`: combine stdout and stderr (bash only)
  ```

---
background-color: #ededed
name:tricks

## More tricks from Buffalo Chapter 3

- **`tee`**: Redirect standard out to file *and* to screen / into a pipe:
  ```sh
  program1 in.txt | tee intermediate-file.txt | program2 > out.txt
  ```
  
<br>

- "Follow" a file, useful to monitor output of a long-running command:
  ```sh
  tail -f                 # Press `Ctrl + C` to stop
  ```
