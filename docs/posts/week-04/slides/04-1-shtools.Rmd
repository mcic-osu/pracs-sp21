---
title: "Week 4 - Unix Data Tools - I"
output:
  xaringan::moon_reader:
    seal: false
    css: ["default", "default-fonts", "slides.css"]
    lib_dir: libs
    nature:
      highlightStyle: rainbow
      highlightLines: true
      countIncrementalSlides: false
---
class:inverse middle center

```{r setup, include=FALSE}
options(htmltools.dir.version = FALSE)

knitr::opts_chunk$set(eval = FALSE)
```

## *Week 4: <br> Unix Data Tools*
----
# Part I: ...

<br> <br> <br> <br> <br>

### Jelmer Poelstra
### 2021/02/02 (updated: `r Sys.Date()`)

---

## Context for this week

In the past two weeks, we learned the basics of the Unix shell.

This week, we'll focus on commands to **inspect and process data**.

We'll revisit some commands we saw in CSB Chapter 1 (`cut`, `uniq`, `grep`, etc),
and will learn several new commands including the two very powerful commands
`sed` and `awk`.

---

## A note before we get started

There are too many commands to remember their details and syntax.

And it is also not necessary to do so!

More important to understand general usage and what's possible, etc.

FWIW, I constantly need to look up syntax even for some of the most common
and basic commands.

---

## Get the files to code-along with Buffalo Chapter 7

- Go to `/fs/ess/PAS1855/$USER`

- Run `git clone https://github.com/vsbuffalo/bds-files.git`

- Move into the newly downloaded dir `bds-files`,  
  and then into `chapter-07-unix-data-tools`.

---

## Head and tail again

- `head` / `tail` will simply show the first / last few lines of a file.
  ```sh
  $ head Mus_musculus.GRCm38.75_chr1.bed # First/last 10 lines
  
  $ head -n 7 Mus_musculus.GRCm38.75_chr1.gtf # Specify with -n
  ```

--

- Skip the first line of a file (*cut off the header*, if you only want the data):
  ```sh
  $ tail -n +6 Mus_musculus.GRCm38.75_chr1.gtf
  $ tail -n +6 Mus_musculus.GRCm38.75_chr1.gtf | head
  ```
--

- Print a specific line number:
  ```sh
  $ head -n 1866 Mus_musculus.GRCm38.75_chr1.bed | tail -n 1
  ```

--

- Also useful to see if a pipeline is doing what it should:

```sh
$ grep "some_string" huge_file.txt | program1 | program2 | head -n 5
```

---

## The `less` pager

- `less` doesn't load entire files into memory: **easy to look at large files**.
  ```sh
  $ less my_file.txt
  
  $ zless my_fastq.gz    # `zless` variant to view zipped files!
  ```

- Now you'll be inside the pager, and your prompt is gone.

--

- Keyboard shortcuts:

| key           | function |
|---------------|----------|
| `q`           | Exit `less`
| `space bar` / `b` | Next / previous page <br>Note: `pgup` / `pgdn` usually also work.
| `d` / `u`     | Go down / up half a page.
| `g` / `G`     | Go to the first / last line (`home` / `end` also work)
|`/<pattern>` / `?<pattern>` | Search forward/backward: next type keyword to search for
| `n` / `N`     | Go to next/previous search match

---
background-color:#e4ede4

## Your turn: `less`

You should be in your `bds-files` directory.

- Open a fastq file with `less`:
  ```sh
  less contaminated.fastq
  ```

- Try to move around a bit.

- Jump to the first and last line.

- Now look for the following pattern:
  "AGATCGG"

- Exit.

---

## File summary information

- Number of lines with `wc -l`:
  ```sh
  $ wc -l contaminated.fastq # Divive by 4 to get the number of sequences
  ```

- File size with `ls -lh` or `du -h`:
  
  ```sh
  ls -lh Mus_musculus.GRCm38.75_chr1.bed
  
  du -h Mus_musculus.GRCm38.75_chr1.bed
  ```

- Counting columns with `awk`:
  ```sh
  awk -F "\t" '{print NF; exit}' file
  ```

---

## More `cut`, and `column` for tabular file viewing

- Tab-delimited files can look messy in the terminal or text editors:

```sh
$ grep -v "^#" Mus_musculus.GRCm38.75_chr1.gtf | cut -f1-8 | head -n3
```

- With `column`, we can make this look better:

```sh
$ grep -v "^#" Mus_musculus.GRCm38.75_chr1.gtf | cut -f 1-8 | \
  column -t | head -n 3
```

--

- `column` can make even more of a difference for CSV files:

```sh
$ column -s "," -t Mus_musculus.GRCm38.75_chr1_bed.csv | head -n 3
```

--

> *`column` illustrates an important point about how we should treat data:*
> *thereâ€™s no reason to make data formats attractive at the expense of readable *
> *by programs.*

---

## Regular expressions ("regex")

- Regular expressions are character sequences defining a search pattern,
  and have many symbols with a special meaning.
  (We'll talk about regex much more in Week 11!)

- Some symbols mentioned in this chapter:

| Symbol            | Meaning | Example
|-------------------|---------|--------
| **`.`**           | Any character | `grep -o "Olfr.*"`
| **`*`**           | Matches preceding<br>character any # times | `grep -o "Olfr.*"`
| **`\t`**          | tab     | `echo -e "column1 \t column2"`
| **`\n`**          | newline | `echo -e "Line1 \n Line2"`
| **`^`** / **`$`** | beginning/end<br>of line | `grep -v "^$"`
| **`\w`**          | alphanumeric<br> character or "_"  | `grep -E -o 'gene_id "\w+"'`
| <code>&#124;</code> | logical or  | <code>grep -E "intron&#124;exon"</code> <br> <code>grep "intron\&#124;exon"</code>

---

## "Basic" versus "Extended" Regular Expressions

- By default, `grep` and `sed` use Basic Regular Expressions (BRE) &mdash;  
to turn on Extended Regular 
  Expressions (ERE), use `grep -E` or `sed -E`.

- Where this gets particularly confusing is that there are both "*POSIX*"
  and "*GNU*" versions of each.
  
  We are using *GNU* tools (if you're on a Mac: see Bonus slide to install
  the *GNU* tools), so the GNU regex are relevant to us.
  
- Differences between BRE and ERE for GNU tools:

| ERE | BRE   | Meaning|
|-----|-------|--------|
| `?` | `\?`  | Matches preceding character at most once
| `+` | `\+`  | Matches preceding character at least once
| `{m,n}`| `\{m,n\}`| Matches preceding character *m* to *n* times
| <code>&#124;</code> | <code>\&#124;</code> | Logical or
|  `\(ab` `\)\1` | `(ab)\1` | Backreference *capture* with () and *recall*<br>with \1; matches "abab"

- `awk` uses ERE by defaults.

---

## Regular expressions versus shell wildcards

| Wildcard  | Regex symbol(s) | Meaning
|-----------|-----------------|--------------------------
| **`?`**   | **`.`**         | Any single character
| **`*`**   | **`.*`**        | Any number of any character
| **`[]`** and **`[^]`**   | same!        | Match/negate match of *character class*

<br>

- Wildcards match *file names*; matches are expanded directly by the shell.

- Regular expressions match any input for the command.

---

## More `grep`

- `grep` will allow partial matching:
  ```sh
  grep "Olfr" Mus_musculus.GRCm38.75_chr1_genes.txt | head -n 5
  ```

- `-v` to invert matches:
  ```sh
  # All strings (gene names) with Olfr except Olfr1413:
  grep "Olfr" Mus_musculus.GRCm38.75_chr1_genes.txt | \
      grep -v "Olfr1413"
  
  # Skip any line begining with a "#":
  grep -v "^#" Mus_musculus.GRCm38.75_chr1.gtf
  ```

- `-w` to match words (consecutive alphanumeric characters *and* "_":
  ```sh
  $ cat example.txt
  
  $ grep bioinfo example.txt
  
  $ grep -w bioinfo example.txt
  ```

---

## More `grep` (cont.)

- Print lines surrounding matches using `-A`, `-B`, and `-C`:
  ```sh
  grep -B1 -A2 "AGATCGG" contam.fastq | head -n 6
  ```
  ```sh
  # Make sure records are not separated by -- lines:
  # grep -B1 -A2 --no-group-separator
  ```

- Match two different records:
  ```sh
  grep "Olfr141[13]" Mus_musculus.GRCm38.75_chr1_genes.txt
  grep -E "(Olfr1413|Olfr1411)" Mus_musculus.GRCm38.75_chr1_genes.txt
  ```

- Count matching lines using `-c`:
  ```sh
  # Count gene names starting with "Olfr":
  $ grep -c "\tOlfr" Mus_musculus.GRCm38.75_chr1_genes.txt
  
  # Count snRNAs:
  $ grep -c 'gene_biotype "snRNA"' Mus_musculus.GRCm38.75_chr1.gtf
  ```

---

## More `grep` (cont.)

- Output only the matching part of the line with `-o`:
  
```sh
# Get all gene names starting with "Olfr":
grep -o "Olfr.*" Mus_musculus.GRCm38.75_chr1_genes.txt | head -n 3

# Extract the quoted word following the gene_id column:
grep -E -o 'gene_id "\w+"' Mus_musculus.GRCm38.75_chr1.gtf | \
    head -n 5
```

- Use a nice little pipeline to get a cleaned list of gene names
  by building on the previous command:

```sh
grep -E -o 'gene_id "\w+"' Mus_musculus.GRCm38.75_chr1.gtf | \
cut -f2 -d" " | \
sed 's/"//g' | \
sort | \
uniq > mm_gene_id.txt
```

---

## More `sort`

- Recap: `-k` to select fields, `n` to turn on *numeric* sorting,
  and `-r` for reverse sorting:
```sh
# Sort a bed file by chromosome and (reversed) start position:
$ sort -k1,1 -k2,2nr example.bed
```

- `-c` to check if a file is sorted &mdash; we get a message when the file is
  *not* sorted, but no output when the file is sorted:
  
  ```sh
  sort -k1,1 -k2,2n -c example.bed
  # sort: example.bed:4: disorder: chr1     40      49
  
  sort -k1,1 -k2,2n -c example_sorted.bed
  ```

- `V` for XX sorting:
  ```sh
  sort -k1,1V -k2,2n example2.bed
  ```

- Show Scientific number sorting?

---

## Exit status of a command

- We could check the *exit status* of the command (0 = success, 1 = fail):

```sh
sort -k1,1 -k2,2n -c example_sorted.bed
echo $?
```

- grep > dev/null example?

---

## More `uniq`: Count occurences with `-c`

```sh
sort letters.txt | uniq -c
```

- This is very useful, e.g. this will output the total number of each type of
  annotated element ("feature") in a genome:
  ```sh
  grep -v "^#" Mus_musculus.GRCm38.75_chr1.gtf | cut -f3 | \
      sort | uniq -c
  ```

- Sort these counts in order from most frequent to least:
  ```sh
  grep -v "^#" Mus_musculus.GRCm38.75_chr1.gtf | cut -f3 | \
      sort | uniq -c | sort -rn
  ```

- Or count combinations across columns &ndash; here features per strand:
  ```sh
  grep -v "^#" Mus_musculus.GRCm38.75_chr1.gtf | cut -f3,7 | \
      sort | uniq -c
  ```

---

## More `uniq`: Count occurences with `-c`

- Check number of different features for a particular gene:
  ```sh
  $ grep "ENSMUSG00000033793" Mus_musculus.GRCm38.75_chr1.gtf | \
      cut -f3 | sort | uniq -c
  ```

- Check for duplicates using `-d`:
  ```sh
  uniq -d mm_gene_names.txt | wc -l
  
  uniq -d test.bed | wc -l
  ```

---

## `join` [OR SKIP JOIN?]

- Also note `paste`

