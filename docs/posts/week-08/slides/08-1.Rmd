---
title: "Week 8 - First steps with Python - I"
output:
  xaringan::moon_reader:
    seal: false
    css: ["default", "default-fonts", "slides.css", "slides_copy.css"]
    lib_dir: libs
    nature:
      highlightStyle: rainbow
      highlightLines: true
      countIncrementalSlides: false
---
class:inverse middle center

```{r setup, include=FALSE}
options(htmltools.dir.version = FALSE)

knitr::opts_chunk$set(eval = FALSE)
```

# *Week 8 - First steps with Python*

----

# I: Jupyter and Python basics

<br> <br> <br> <br> <br>

### Jelmer Poelstra
### 2021/03/02 (updated: `r Sys.Date()`)

---

## Overview of this week

We will work our way through the CSB chapter 3.1-3.4 to get started
with Python using Jupyter Notebooks.

Thursday will focus entirely on section 3.4: Python data structures.

---
class: inverse middle center

# Overview of this presentation

----

.left[
- ### [What is Python and why Python](#python)
- ### [Jupyter Notebooks](#python)
- ### [CSB 3.3: Getting started with Python](#getting-started)
]

---
name: python

## What is Python?

- Python is an all-purpose programming language that was created by
  Guido van Rossem, first released in 1991, and named after Monty Python.

- ["The Zen of Python"](https://www.python.org/dev/peps/pep-0020/)
  describes guidelines for Python code with aphorisms that include:

  - Beautiful is better than ugly.
  - Explicit is better than implicit.
  - Simple is better than complex.
  - Complex is better than complicated.
  - Readability counts.
  - If the implementation is hard to explain, it's a bad idea.
  - There should be one-- and preferably only one --obvious way to do it.

- The last point relates to the notion of "Pythonic" code that follows these
  and other [style guidelines](https://pep8.org/).

---

## Why Python?

### Show language popularity graph

- Good language for new programmers due to its straightforward,
  highly readable style.

- Lot of built-in features that would require third-party libraries in other
  languages.
  
- Excellent availability of third-party libraries.

- Cross-platform, open source, and very popular.

---

## Usage of Python

- Data science (especially machine learning)

- Engineering, electronics, astronomy, biology / bioinformatics

- Websites

- Software like the Dropbox client

- Widely used for games and movies

- One of the 4 official languages of Google (along with Java, C++, and Go)

- Tightly integrated with Linux, e.g. Ubuntu Linux prefers community
  contributions to be in Python.

---
name: jupyter

## Starting JupyterLab at OSC

1. Log in to <https://ondemand.osc.edu>.

2. Click on `Interactive Apps` (top blue bar) and then
   `Jupyter (Owens and Pitzer)` near the bottom.

3. In the form for your compute node options:
   
   - Cluster: either `pitzer` or `owens` works.
   - Project: our course project `PAS1855`.
   - **Check the box `Use JupyterLab instead of Jupyter Notebook?`**
   - Number of hours: 1 or 2.
   - Node type: keep the default selection, `any`.
   - Number of cores: keep the default selection, `1`.
   - JupyterLab Version: keep the default selection, `2.1`.
   - Click `Launch`.

4. Once the compute node is `Running`, click `Connect to Jupyter`.

---

## JupyterLab setup

- One peculiarity about Jupyter is that you can't really go *up* in the directory
  tree from your entry point.
  
  Additionally, OSC gave us no choice on where to start,
  and placed us in our home (`$HOME`, `~`) directory.

- While you can save your JupyterLab notebooks in your home directory,
  it will be more organized to save them in your personal dir in the
  course project dir.
  
  To be able to do that, we need a link to there from our home dir.
  
--

- On the JupyterLab front page ("Launcher"), click `Terminal`.

  In the terminal, create a link (in the example below, the link will be
  named `pp8300_sp21`, but you can use a different name):
  
  ```sh
  $ ln -s /fs/ess/PAS1855/users/$USER/ pp8300_sp21
  
  # While we're at it, let's create a dir for this week:
  $ mkdir pp8300_sp21/week08
  ```

---

## JupyterLab setup & first steps

- Click on the folder icon in the top of the vertical bar on the right-hand side
  (`File Browser`). You should see your link to the project dir &ndash;
  if not, click the refresh icon in the top.
  
- Click on your link. You should now see this path at the top of your Launcher
  window.

- Click on `Python 3` (leftmost box) to start a JupyterLab Notebook.

--

- Another Jupyter peculiarity is that it will automatically start saving any
  new notebook as `Untitled.ipynb`.
  But we will want to save the notebook under a useful name,
  so in the File Browser, find the current notebook and:
  - Move it into the `week08` dir.
  - Right-click the file, then `Rename`,
    and rename the file to (e.g.) `Tuesday.ipynb`.

---

## Testing the JupyterLab notebook

- Press <kbd>Esc</kbd> (or <kbd>Ctrl</kbd>+<kbd>M</kbd>)
  and then <kbd>M</kbd> to make the cell in the notebook into
  a *Markdown cell*, type "# Week 7 - Tuesday", and press
  <kbd>Shift</kbd>+<kbd>Enter</kbd> to *run* the cell.
  
  You should now see Markdown formatting being applied.

- In the next cell, which is a code cell by default,
  type `30 * 2` and again press <kbd>Shift</kbd>+<kbd>Enter</kbd> to *run* the
  cell.
  
  You should see the result of the calculation being printed.

---

## What is Jupyter?

Like bash and R, Python can be used both *interactively* (issue one command
at a time, get instantaneous feedback) or *non-interactively* by running a
script with Python code.

We will start by using Python interactively, and will do so using  
**JupyterLab**:

--

- A browser-based environment that runs locally on your computer.

- Jupyter = **Ju**lia, **Py**thon, **R**
  (but now compatible with other languages too).
  
- Combines Markdown "cells" with code cells,
  and will also show results and figures inside the same document.

- Files are saved as `.ipynb` (IPYthon Notebook) files in *JSON* format,
  but you don't tend to interact with the raw files outside of the Jupyter
  environment.
  
<br>

.content-box-info[
*Jupyter Lab* is a quite similar follow-up to Jupyter Notebooks.
]

---

## Working in JupyterLab

- The main left sidebar has several tabs that you can switch between by clicking
  on the far left, narrow sidebar. Most useful are: 
  
  - The "File Browser".
    Note that you can right-click on files and dirs to rename them, etc.
    Here, you can also open a new "Launcher" tab by clicking the `+` button.
  
  - The "Commands" sidebar (magnifying glass icon), which has all the Jupyter
    commands and their keyboard shortcuts. 

  You can show/hide the left Sidebar by clicking `View` => `Show Left Sidebar`.

- Jupyter uses the term *"kernel"* to refer to processes for running code,
  such as an individual notebook running a specific version of Python. 

---

## Working in JupyterLab Notebooks

- <kbd>Shift</kbd>+<kbd>Enter</kbd> &ndash; run a cell and move to the next one.

- <kbd>Esc</kbd> or <kbd>Ctrl</kbd>+<kbd>M</kbd> &ndash; go into "**command mode**",
  then:
  
  - <kbd>M</kbd> &ndash; Change cell type to Markdown.
  
  - <kbd>Y</kbd> &ndash; Change a cell to code.
  
  - <kbd>A</kbd> &ndash; Create a new cell above the current cell.
  
  - <kbd>B</kbd> &ndash; Create a new cell above the current cell.
  
  - <kbd>D</kbd>,<kbd>D</kbd> &ndash; Delete the current cell.

- You can also right-click in a cell to see more actions.

---

class: center middle inverse
name: getting-started

# 3.3. Getting started with Python

-----

<br> <br> <br> <br>

---

## Simple calculations

- We can use Python as an oversized calculator:

  ```sh
  >>> 2 + 2         # Addition
  #> 4
  >>> 2 * 2         # Multiplication
  #> 4
  >>> 3 / 2         # Division
  #> 1.5
  ```

--

- The usual precedence rules apply, but it's better to be explicit with
  parentheses:

  ```sh
  >>> 2 * 3 ** 3    # Read as 2*(3**3)
  #> 54
  
  >>> 2 * (3 ** 3)
  #> 54
  
  >>> (2 * 3) ** 3
  #> 216
  ```

---

## Simple calculations (cont.)

- **Integer division** (AKA floor division) is division in which the
  fractional part (remainder) is discarded:

  ```sh
  >>> 3 // 2        # Integer division
  #> 1
  ```

<br>

- **The modulo operator** returns the remainder of an integer division:

  ```sh
  >>> 15 % 7
  #> 1
  ```
  
  _(As 15 = (7*2) + 1), 1 is the remainder of the integer division 15//7.)_
  

--

<br>

.content-box-info[
Like in Bash and other languages, anything after a pound sign `#` is ignored
by Python and generally functions as a "comment".
]

---

## Logical operators: `True`, and `False`

- Logical operators return a Boolean value,
  which in Python consist of `True` and `False` (with that exact case):
  
  ```sh
  >>> 2 > 3 # 
  #> False
  
  >>> 2 == 2 # equals
  #> True
  
  >>> 2 != 2 # is different
  #> False
  ```

---

## Quoting defines strings

- Quotes define strings, and you can single, double, triple-single,
  or triple-double quotes &ndash; but always make sure to use the same closing
  quote as the opening quote.

  ```sh
  >>> 'my string'
  >>> "my string"
  >>> '''my string'''
  >>> """my string"""
  #> 'my string'
  ```
  
- Being able to use single versus double quotes helps if your string contains
  one of those:
  
  ```sh
  >>> "The tree's height"
  #> 'The tree's height'
  ```
  
- And triple quotes are useful if your string contains both single and double quotes:  
  
  ```sh
  # """The tree ' s height is 6 ' 2"."""
  #> 'The tree\'s height is 6\'2".'
  ```

- Moreover, triple quotes can be used for multiline strings:

  ```sh
  """This
  is a mult-line
  string"""
  ```

.content-box-q[
How might we be able to create a multi-line string using single/double quotes?
]

---

## Variable assignment

From working with Bash,
we are familiar with the process of assigning variables (also known as
"declaring variables") and then using them.  

- This works the same in Python, but when recalling a variable,
  we don't need any special syntax (like `$` in bash):

  ```sh
  >>> x = 5
  >>> x
  #> 5
  ```

--

- Like in bash, we can use variables to perform further calculations --
  they will simply be replaced by whatever value they hold:
  
  ```sh
  >>> x + 3
  #> 8
  >>> y = 8
  >>> x + y
  #> 13
  ```

.content-box-info[
Python is not sensitive to spaces around the `=` for assignment. 
]

---

## Variable assignment (cont.)

- When we assign a variable to a *new* variable, a new object is created,
  and the two are *not* linked:
  
  ```sh
  >>> x
  #> 5
  >>> y = x
  >>> y
  #> 5
  
  >>> y = y + 10
  >>> y
  #> 15
  >>> x
  #> 5
  ```

--

<br>

.content-box-info[
This behavior of "unlinked variables" may be very intuitive or expected &ndash;
but in Python, this is only true for *immutable* objects!
]

---

## Variable types

- Unlike in bash, variables in Python have *types*, such as:
  - Integers (whole numbers)
  - Floats (numbers with decimal points)
  - Strings
  - Boolean (`True` or `False`)

- Assign a string, and concatenate strings with `+`:

  ```sh
  >>> x = "The cell grew"
  
  >>> x + " and is now larger"
  #> 'The cell grew and is now larger'
  ```

--

.content-box-info[
Jupyter functions to show what's in your environment:

```sh
>>> who

>>> whos

>>> dir()
```
]

---

## Variable types

We can't perform operations like concatenation with variables of different types:

```sh
>>> y
#> 8
>>> x
#> "The cell grew"

>>> x + y              # x is string, y is integer
#> ---------------------------------------------
#> TypeError
#> Traceback (most recent call last)
#> <ipython-input-8-b50c5120e24b> in <module>()
#> ----> 1 x + y
#> TypeError: Can't convert ' int ' object to str implicitly
```

---

## Variable type conversion

```sh
>>> x
#> "The cell grew"
>>> y
#> 8
```

- But we can convert variable types on the fly; to as string with `str()`:
  
  ```sh
  >>> x + " " + str(y) + " nm"
  #> ' The cell grew 8 nm '
  ```

--

- To an integer with `int()`:

  ```sh
  >>> y + int(z)
  #> 96
  ```

--

- Numbers in quotes are interpreted as strings:
  
  ```sh
  >>> z = "88" # string
  >>> x + z
  #> 'The cell grew88'
  ```

---

## Variable type conversion

As we just saw, Python types variables *dynamically* (also known as "duck typing").
This means you don't have to a priori define what type a variable should be.
You can check *what Python has decided for you* using `type()`:

```sh
>>> x = 2
>>> type(x)
#> int

x = "two"
>>> type(x)
#> str
```

--

- These are all the functions to convert between types:

|Function     | Convert to:
|-------------|--------------|
| `int()`     | Integer
| `double()`  | Double (numbers with decimals)
| `str()`     | String
| `bool()`    | Boolean (`True` / `False`)

---

## Naming variables

- Use only alphanumeric characters and underscores in variables names.

- Numbers can't be used as the *first character* in variable names.

- To delimit words, preferably use underscores (`my_variable`) rather than
  "camel case" (`MyVariable`).
  (And note that Python is case-sensitive.)

- As we'll see in a minute, periods `.` have special meaning in Python and
  **can not** be used in variable names.

---

## Built-in functions

- In the previous slide, we saw several examples of *functions*,
  which are called using parentheses:
  
  ```sh
  # With no arguments specified:
  function_name()
  
  # With arguments specified:
  function_name(function_argument1, function_argument2)
  ```

--

- For example, we can use `len()` to get the length of (e.g.) a string:

  ```sh
  >>> s = "a long string"
  >>> len(s)
  #> 13
  ```

--

- Or `round()` to round a number, with an optional number of decimals to round
  to (the default is 0):

  ```sh
  >>> round(3.14159)
  #> 3
  >>> round(3.14159, 3)
  #> 3.142
  ```

---

## Printing to screen

.content-box-info[
As we've seen, when we typed `x` or `x + y`, the outcome was printed to screen.

However, this only happens in interactive Python; and in Jupyter Notebooks,
only for the last command:

```sh
>>> x
>>> z
#> '88'
```

To be more explicit, and to print in any context, we can use the function
`print()`:

```sh
>>> print(x)
>>> print(z)
#> 2
#> '88'
```
]

---

## Strings and methods

- **Python is "object-oriented"** &ndash;
  its variables are objects that contain:
  
  - The values/data assigned to them, _and_
  
  - A type of functions specifically associated with the object type.
    These are called **"methods"**.
    
--

- Let's call a method &mdash; here, we'll try `find()`,
  which prints the position of the first occurrence of a substring:
  
  ```sh
  >>> astring.find("C")
  #> 3
  ```

---

## Getting help in Python / Jupyter

.content-box-info[
- To see which methods are associated with a string,
  type a dot `.` after an object name, and press <kbd>Tab</kbd>:
  
  ```sh
  >>> astring = "ATGCATG"
  >>> astring.      # Press Tab
  ```

- To get help about methods/objects/etc, press Shift-tab:
  ```sh
  >>> astring.     # Press Shift-tab for help on strings
  >>> astring.find # Press Shift-tab for help on find
  
  # Or:
  >>> help(astring.find)
  >>> ?astring.find
  >>> ?astring
  ```
  
  On the internet, <https://docs.python.org> should be your go-to source.
]

---

## *Methods* versus (generic) *functions*

- Call the function `print()` on a string:

  ```sh
  >>> s = "ATGC"
  
  >>> print(s)
  #> ATGC
  ```

- Calling the method "print" returns an error message
  that tells us that strings have no method called `print`:

  ```sh
  >>> s.print()
  #> ----------------------------------------------------------
  #> AttributeError: ' str ' object has no attribute ' print '
  ```

--

.content-box-info[
**Comparing the syntax for generic functions and methods:**

```sh
function_name(object, other_argument)

object.method_name(argument)
```
]

---

## More methods for strings

- `.replace()` to replace substrings:
  
  ```sh
  # astring = "ATGCATG"
  
  >>> astring.replace("T", "U")
  #> 'AUGCAUG'
  ```

- `count()` to count occurrences of substrings:

  ```sh
  >>> astring.count("G")
  #> 2
  ```

--

- `.split()` will split a string into components, using spaces by default:

  ```sh
  >>> newstring = " Mus musculus "
  
  >>> newstring.split()
  #> ['Mus', 'musculus']
  
  # Specify the character by which to split:
  >>> newstring.split("u")
  #> ['M', 's m', 'sc', 'l', 's']
  ```

---

## More methods for strings

- `.strip()` to remove, by default, leading and trailing white space:

  ```sh
  # newstring = " Mus musculus "
  
  >>> newstring.strip()
  #> 'Mus musculus'
  ```

- `.index()` &ndash; returns the position of a substring like `.find()`,
  but will raise an error if the substring is not found
  (`.find()` will return a value of `-1`).

---

## Other behavior of methods

- You can even use string methods without first assigning the string to a
  variable:
  
  ```sh
  # Make uppercase with `.upper()`:
  >>> "atgc".upper()
  #>'ATGC'
  
  # Make lowercase with `.lower()`:
  >>> "TGCA".lower()
  #> 'tgca'
  ```

--

<br>

- And you can **combine multiple methods** in a single call
  by chaining them together like so:

  ```sh
  # astring = "ATGCATG"
  
  >>> astring.replace("T", "U").count("U")
  #> 2
  ```
  
---

## Concatenating strings

- We can concatenate string with the `+` sign:

  ```sh
  >>> genus = "Rattus"
  >>> species = "norvegicus"
  
  >>> genus + " " + species    # Separate with a space
  #> 'Rattus norvegicus'   
  ```

--

- But this is a slow way of concatenating &ndash;
  the `.join()` method is better:

  ```sh
  # join requires a list of strings as input:
  >>> human = ["Homo", "sapiens"]
  >>> " ".join(human)
  #> 'Homo sapiens'
  
  # You can specify any symbol as a delimiter:
  >>> "->".join(["one", "leads", "2", "the", "other"])
  #> 'one->leads->2->the->other'
  ```
  
---

## More on methods

- Different object types have different methods:

  ```sh
  >>> my_int = 8
  >>> my_int.               # See methods for integers 
  
  >>> my_float = 8.5
  >>> float.                # See methods for floats
  
  >>> mystring = "ATGC"
  >>> my.string.            # See methods for strings
  ```

---

## `r icon::fa("user-edit")` Intermezzo 3.1

1. Initialize the string `s = "WHEN on board H.M.S. Beagle, as naturalist"`.

2. Apply a string method to count the number of occurrences of the
   character `b`.

3. Modify the command such that it counts both lowercase and uppercase `b`'s.

4. Replace `WHEN` with `When`.

---

## `r icon::fa("user-edit")` Intermezzo 3.1: Solutions

1. Initialize the string:

  ```sh
  >>> s = "WHEN on board H.M.S. Beagle, as naturalist"
  ```

2. Count the number of occurrences of the character `b`.

  ```sh
  >>> s.count("b")
  ```

3. Count both lowercase and uppercase `b`'s:

  ```sh
  >>> s.lower().count("b")
  ```

4. Replace `WHEN` with `When`.

  ```sh
  >>> s.replace("WHEN","When")
  ```

---
class: center middle inverse

# Questions?

-----

<br> <br> <br> <br>

