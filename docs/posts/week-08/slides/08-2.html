<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Week 8 - First steps with Python - II</title>
    <meta charset="utf-8" />
    <script src="libs/header-attrs/header-attrs.js"></script>
    <link href="libs/remark-css/default.css" rel="stylesheet" />
    <link href="libs/remark-css/default-fonts.css" rel="stylesheet" />
    <link href="libs/font-awesome/css/fontawesome-all.min.css" rel="stylesheet" />
    <link rel="stylesheet" href="slides.css" type="text/css" />
    <link rel="stylesheet" href="slides_copy.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">

class:inverse middle center



# *Week 8 - First steps with Python*

----

# II: Data structures

&lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt;

### Jelmer Poelstra
### 2021/03/04 (updated: 2021-03-04)

---
class: inverse middle center

# Overview

----

.left[
- ### [Lists](#lists)
- ### [Dictionaries](#dicts)
- ### [Tuples](#tuples)
- ### [Sets](#sets)
]

---
class: center middle inverse
name: lists

# Lists

-----

&lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt;

---

## Lists

**A list stores a collection of items, similar to arrays in Bash.**

A list is denoted with square brackets `[]`,
and with individual items (elements) separated by commas.
  
- Two ways to create an empty list:

  ```python
  new_list = []
  
  another_list = list()
  ```

- Create a list with values &amp;ndash; note that they don't have to be of the
  same type:
  
  ```python
  first_list = ["a", "e", "g"]
  second_list = [45, 33, 99]
  third_list = [3, 2.44, "green", True]
  ```
  
--

- We can also convert other object types, such as a string, into a list:
  
  ```python
  a = list("0123456789")
  a
  #&gt; ['0' ,'1', '2', '3', '4', '5', '6', '7', '8', '9']
  ```

---

## Accessing list elements &amp;ndash; and zero-indexing

- We can access items within a list by indicating position(s)
  within square brackets. For instance:

  ```python
  my_list = ['a', 'b', 'c', 'd', 'e']
  
  my_list[1]
  #&gt; 'b'
  ```

  But this returns the *second* item!

--

- **Python starts counting at 0**,
  so the first element corresponds to index 0:

  ```python
  my_list[0]
  #&gt; 'a'
  ```

---

## Accessing list elements &amp;ndash; and zero-indexing (cont.)

- Moreover, when using *ranges*, such as with a colon `:`,  
  **the item corresponding to the last index is not included:**

  ```python
  # my_list = ['a', 'b', 'c', 'd', 'e']
  
  my_list[0:3]    # Elements 1, 2 and 3
  #&gt; ['a', 'b', 'c']
  
  my_list[1:3]    # Elements 2 and 3
  #&gt; ['b', 'c']
  ```

--

- Therefore, a range of two successive indices returns a single-item list:
  
  ```python
  my_list[0:1]    # First item in single-element list
  # ['a']           
  
  # Use a single index to return a "str":
  my_list[0]      # First item as a "str"
  #&gt; 'a'
  ```

---

## Zero-indexing with half-open intervals

&lt;br&gt;

&lt;figure&gt;
&lt;p align="center"&gt;
&lt;img src=img/indexing1.svg width="100%"&gt;
&lt;/p&gt;
&lt;/figure&gt;

---

## Zero-indexing with half-open intervals

&lt;br&gt;

&lt;figure&gt;
&lt;p align="center"&gt;
&lt;img src=img/indexing2.svg width="100%"&gt;
&lt;/p&gt;
&lt;/figure&gt;

---

## More indexing with a colon (i.e., "slicing")

- When using a colon to indicate a range,
  as we did in the previous slide,
  numbers on either side of the colon are optional:

  ```python
  # my_list = ['a', 'b', 'c', 'd', 'e']
  
  # From the first element until element 3 (noninclusive):
  my_list[:3]      
  #&gt; ['a', 'b', 'c']
  
  # From element 4 to the last element:
  my_list[3:]      
  #&gt; ['d', 'e']
  ```

--

- As it stands to reason, we can therefore return the whole list with `[:]`:

  ```python
  my_list[:]
  #&gt; ['a', 'b', 'c', 'd', 'e']
  ```

---

## Indexing with negative numbers

- You can use *negative numbers* to index starting from the end:

  ```python
  # my_list = ['a', 'b', 'c', 'd', 'e']
  
  my_list[-1]     # Last element
  #&gt; 'e'
  
  my_list[-2]     # Second-to-last element
  #&gt; 'd'
  ```

- And this works with ranges as well - the default direction is still positive:

  ```python
  my_list[-3:-1]  # Third-to-last to last element (noninclusive)
  #&gt; ['c', 'd']
  ```

---

## Indexing with negative numbers

&lt;figure&gt;
&lt;p align="center"&gt;
&lt;img src=img/indexing3.svg width="100%"&gt;
&lt;/p&gt;
&lt;/figure&gt;

---

## Indexing with negative numbers

&lt;figure&gt;
&lt;p align="center"&gt;
&lt;img src=img/indexing4.svg width="100%"&gt;
&lt;/p&gt;
&lt;/figure&gt;

---

## Indexing with two colons

When using **two colons**, the third element is the direction and stride.

- The default stride is `1` (positive 1):

  ```python
  # my_list = ['a', 'b', 'c', 'd', 'e']
  
  my_list[:3:1]
  #&gt; ['a', 'b', 'c']
  ```

- We can take every second element with a stride of `2`:  
  
  ```python
  my_list[::2]
  #&gt; ['a', 'c', 'e']
  ```

- And we can reverse the list with a stride of `-1`:

  ```python
  my_list[::-1]    # Go backward with stride 1 and take whole list
  #&gt; ['e', 'd', 'c', 'b', 'a']             
  ```

---

## Chaining indexing

- Since we can also index strings:

  ```python
  seq = 'GTACAG'
  seq[3]
  #&gt; C
  ```

- ...we can use index chaining to, for example, index a string inside a list:

  ```python
  seqlist = ['AACGT', 'GTACAG', 'CTCTA']
  seqlist[1][3]
  #&gt; C
  ```

---

## Bad indexing

- When your index attempt contains a contradiction between the *implicit*
  direction (to:from) and the *explicit* direction (stride),
  an empty list is returned:

  ```python
  my_list[-1:-3]    # With no stride indicated, it defaults to 1
  #&gt; []
  ```

--

- When your indexing range reaches beyond the last element,
  everything until the last element will simply be returned:
  
  ```python
  my_list[0:10]
  #&gt; ['a', 'b', 'c', 'd', 'e']
  ```

--

- But when you try to access an individual nonexistent element,  
  you will get an error:

  ```python
  my_list[5]
  #&gt; ...
  #&gt; IndexError: list index out of range
  ```

---

## Operating on lists with `+` and `*`

- Like strings, we can concatenate two lists with `+`:

  ```python
  # my_list = ['a', 'b', 'c', 'd', 'e']
  # a = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']
  a + my_list
  #&gt; ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e']
  ```

--

- We *can't* add individual elements like this:

  ```python
  a + 1
  #&gt; TypeError: can only concatenate list (not "int") to list
  ```

- But we can add a list that we define on the fly, including a single-element one:

  ```python
  a + [1]
  #&gt; ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 1]
  ```

---

## Operating on lists with `+` and `*`

- Using the multiply operator, the list contents will be *repeated* n times:

  ```python
  a * 2
  #&gt; ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9']
  
  samples = ['red'] * 5
  samples
  # ['red', 'red', 'red', 'red', 'red']
  ```

--

&lt;br&gt;

.content-box-info[
Like the `+` operator, the `*` operator works equivalently on lists and strings:

```python
my_repeat = "AGAAG"
my_repeat * 3
#&gt; 'AGAAGAGAAGAGAAG'
```
]

---

## Side note: No automatic element-wise actions

.content-box-info[
As the addition and multiplication of lists above already hinted at,
Python operations do not by default act element-wise
(unlike in R, where many operations are *vectorized*).

To operate on each element of a list, we can:

- Use a loop (next week), a *list comprehension* (next week),
  or the `map()` function.

- Use *arrays* from the NumPy module to get R-like behavior.
]

---

## Updating a list element

- We can *update* an element using index notation:

  ```python
  my_list = [3, 2.44, "green", True]
  my_list[0] = "blue"
  my_list
  #&gt; ['blue', 2.44, 'green', True]
  ```
  
---

## List methods

- `append` &amp; `extend` &amp;ndash; Append one / multiple element(s) to the end of the list:

  ```python
  my_list.append(25)          # append: single item
  my_list
  # ['blue', 2.44, 'green', True, 25]
  
  my_list.extend(['red', 0])  # extend: multiple items
  my_list
  # ['blue', 2.44, 'green', True, 25, 'red', 0] 
  ```

---

## List methods (cont.)

- To delete one or more elements *by index*, use the *function* `del()`:
  
  ```python
  del(my_list[2:4])        # Delete 3rd and 4th element 
  a
  #&gt; ['blue', 2.44, 25, 'red', 0]
  ```
  
- To delete one element *by value*, use the method `remove()`:

  ```python
  my_list.remove('red')
  my_list
  #&gt; my_list.remove('red')
  ```
  
--

- To remove all elements from the list, use the method `clear()`:

  ```python
  my_list.clear()
  my_list
  #&gt; []
  ```

---

## List methods (cont.)

```python
seq = list("TKAAVVNFT")
seq
#&gt; ['T', 'K', 'A', 'A', 'V', 'V', 'N', 'F', 'T']
```
  
- `count` &amp;ndash; Count occurrences of a certain item in the list:
  
  ```python
  seq.count("V")
  #&gt; 2
  ```

--

- `index` &amp;ndash; Return the index corresponding to first occurrence of an
  item:

  ```python
  seq.index("V")
  #&gt; 4
  ```

--

- `pop` &amp;ndash; Remove the last item in the list and return it:

  ```python
  seq_last = seq.pop()
  seq
  #&gt; ['T', 'K', 'A' , 'A' , 'V', 'V' ,'N', 'F']
  seq_last
  #&gt; 'T'
  ```

---

## List methods (cont.)

- `sort` &amp;ndash; Sort the elements *in place*:

  ```python
  my_list = [1, 5, 2, 42, 14, 132]
  my_list.sort()
  my_list
  #&gt; [1, 2, 5, 14, 42, 132]
  ```

--

- `sorted` function &amp;ndash; Return a sorted list:

  ```python
  sorted_list = sorted(my_list)
  
  my_list
  #&gt; [1, 5, 2, 42, 14, 132]
  sorted_list
  #&gt; [1, 2, 5, 14, 42, 132]
  ```

--

- `reverse` &amp;ndash; Reverse the order of the elements:

  ```python
  my_list.reverse()
  my_list
  #&gt; [132, 42, 14, 5, 2, 1]
  ```

---

## Modifying lists: in-place-acting methods

We've seen that many of the methods in the previous slides modify lists
*in place*, which is something you may not be used to.

```python
reversed_list_maybe = my_list.reverse()

reversed_list_maybe
#&gt;

my_list
#&gt; [1, 2, 5, 14, 42, 132]
```

---

## Modifying lists: &gt;1 name referring to the same list

Also of note is that when we assign an existing list to a new name,  
this will *not* create a new list in the way we saw with simple variables.

```python
list_b = my_list
```

Instead, both names (`list_b` and `a`) now are separate pointers to the *same*
list &amp;ndash; if we modify one, the other will also change:

```python
list_b = list_b.append("Exclusive to list b?")

my_list
#&gt; [1, 2, 5, 14, 42, 132, "Exclusive to list b?"]
```

--

&lt;br&gt;

.content-box-info[
Python exhibits this type of behavior for all mutable data types.

To break this "linkage", we need to explicitly create a copy of the list
(next slide).
]

---

## Strings versus lists

- Because strings are immutable, assigning a new variable name will always create
  an entirely new, unlinked variable &amp;ndash; recall from Tuesday:

  ```python
  x = 5
  y = x
  y = y + 10
  y
  #&gt; 15
  x
  #&gt; 5
  ```

--

- We saw earlier that strings can be indexed like lists:

  ```python
  seq = "ATGCATG"
  seq[2]
  #&gt; 'T'
  ```

--

- So can we use this for assignment too? No, because strings are immutable unlike lists.

  ```python
  seq[2] = "U"
  #&gt; TypeError: 'str' object does not support item assignment
  ```

---

## Copying lists

- `copy` &amp;ndash; Create a copy of the list:

  ```python
  import copy
  new_list = my_list.copy()
  new_list
  #&gt; ['blue', 2.44, 'green', True, 25, 'red', 0] 
  ```

- Or use `[:]` notation:

  ```python
  another_list = my_list[:] 
  ```

--

- Now, these lists can be modified independently:

  ```python
  new_list.clear()
  my_list
  #&gt; [1, 2, 5, 14, 42, 132]
  
  another_list.clear()
  my_list
  #&gt; [1, 2, 5, 14, 42, 132]
  ```

---
class: center middle inverse
name: dicts

# Dictionaries

-----

&lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt;

---

## Dictionaries

Dictionaries are like *unordered* lists in which the elements (**values**)
are indexed by **keys**.

- Create an empty dictionary using curly braces or the `dict()` function:

  ```python
  empty_dict_1 = {}
  empty_dict_2 = dict()
  ```

- And one with items using `key: value` notation inside curly braces:

  ```python
  GenomeSize = {"Homo sapiens": 3200.0,
                  "Escherichia coli": 4.6,
                  "Arabidopsis thaliana": 157.0}
  GenomeSize
  #&gt; {'Arabidopsis thaliana ' : 157.0,
  #&gt;  'Escherichia coli' : 4.6,
  #&gt;  'Homo sapiens' : 3200.0}
  ```

--

- Values of dictionaries can also be lists:

  ```python
  my_dict = {"a": "test",
               "b": [1, 2, 3, 4]}
  ```

---

## Dictionaries are unordered

- The order of the keys does not matter,
  and in fact is not retained as it was entered:
  
  ```python
  GenomeSize = {"Homo sapiens": 3200.0,
                  "Escherichia coli": 4.6,
                  "Arabidopsis thaliana": 157.0}
  GenomeSize
  #&gt; {'Arabidopsis thaliana ' : 157.0,
  #&gt;  'Escherichia coli' : 4.6,
  #&gt;  'Homo sapiens' : 3200.0}
  ```

--

.content-box-info[
**Unordered versus ordered data structures**  
Even though lists may or may not be sorted in a systematic way,
they are always said to be ordered in the sense that:
- The position for each item is retained unless explicitly changed.
- Items can thus accessed using their position (`my_list[5]`).

This is not true for (default) dictionaries:
they cannot be sorted, and the order of the items varies stochastically.
]

---

## Dictionaries are unordered (cont.)

- In dictionaries, values are therefore recalled not with an index,
  but with the name of their corresponding key:
  
  ```python
  GenomeSize["Arabidopsis thaliana"]
  #&gt; 157.0
  ```

---

## Dictionaries (cont.)

- New values can be added simply by assigning a new key:

  ```python
  GenomeSize["Saccharomyces cerevisiae"] = 12.1
  GenomeSize
  #&gt; {' Arabidopsis thaliana': 157.0,
  #&gt; 'Escherichia coli': 4.6,
  #&gt; 'Homo sapiens': 3200.0,
  #&gt; 'Saccharomyces cerevisiae': 12.1}
  ```

--

- If the key-value pair already existed, nothing happens:

  ```python
  GenomeSize["Escherichia coli"] = 4.6
  ```

--

- But the old value will be overwritten if the new one is different:
  
  ```python
  GenomeSize["Homo sapiens"] = 3201.1
  GenomeSize
  #&gt; {'Arabidopsis thaliana': 157.0,
  #&gt; 'Escherichia coli': 4.6,
  #&gt; 'Homo sapiens': 3201.1,
  #&gt; 'Saccharomyces cerevisiae': 12.1}
  ```

---

## Functions and methods for dictionaries

- As with lists, items can be deleted with the `del()` function:

  ```python
  del(GenomeSize['Homo sapiens'])
  ```

--

- Also like lists, dictionaries have `.copy()` and `.clear()` methods:

  ```python
  GS = GenomeSize.copy()  # Create a copy
  
  GS.clear()              # Remove all entries
  GS
  #&gt; {}
  ```

--

- `.pop()` removes the specified key and returns the corresponding value:

  ```python
  GenomeSize.pop("Escherichia coli")
  #&gt; 4.6
  
  GenomeSize
  #&gt; {'Arabidopsis thaliana': 157.0,
  #&gt; 'Saccharomyces cerevisiae': 12.1}
  ```
  
---

## Functions and methods for dictionaries

- The methods `keys()` and `values()` create list-like objects from the keys
  and values:
  
  ```python
  GenomeSize.keys()
  #&gt; dict_keys(['Arabidopsis thaliana', 'Saccharomyces cerevisiae'])
  
  GenomeSize.values()
  #&gt; dict_values([157.0, 12.1])
  ```

- And similarly `items()` returns each full item, i.e. each key-value pair:

  ```python
  GenomeSize.items()
  #&gt; dict_items([('Arabidopsis thaliana', 157.0), ('Saccharomyces cerevisiae', 12.1)])
  ```
  
---

## Functions and methods for dictionaries (cont.)

- We can merge two dictionaries using `.update()`:

  ```python
  D1 = {"a": 1, "b": 2, "c": 3}
  D2 = {"a": 2, "d": 4, "e": 5}
  
  D1.update(D2)
  D1
  #&gt; {'d': 4, 'e': 5, 'b': 2, 'a': 2, 'c': 3}
  ```

  With `.update()`, the order matters: for keys present in both dictionaries
  but with different values, the value of the *second* dictionary will
  overwrite that of the first.
  
---

## Functions and methods for dictionaries

- We saw that we can extract a value with square brackets,
  but we can also use the `.get()` method.
  This will make a difference when the key does not exist &amp;ndash;
  and we can even specify a default value with `.get()`:
  
  ```python
  GenomeSize["Mus musculus"]
  #&gt; KeyError: 'Mus musculus'
  
  GenomeSize.get("Mus musculus")
  #&gt; 
  
  GenomeSize.get("Mus musculus", -10)
  #&gt; -10
  ```

--

.content-box-info[
In the second example, nothing was printed,
but `.get()` actually returned `None`,
Python's keyword to define a null value.  
We can see this by using the `print()` function:

```python
print(GenomeSize.get("Allium cepa"))
#&gt; None
```
]

---
class: center middle inverse
name: tuples

# Tuples

-----

&lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt;

---

## Tuples

Tuples are similar to lists, in that they contain a sequence of values of any
type, **but they are immutable:** the values cannot be changed once the
tuple has been defined.

This behavior provides write-protection, and makes tuples faster than lists.

- Empty tuples are created using parentheses `()` or `tuple()`:
  
  ```python
  empty_tuple_1 = ()
  empty_tuple_2 = tuple()
  ```

- And tuples with items are created using parentheses,
  with a trailing comma being needed when createing a single-item tuple:

  ```python
  my_tuple = (1, "two", 3)
  single_element_tuple = (4, )   # Trailing comma needed
  ```

---

## Tuples (cont.)

- Tuples can be indexed like lists:

  ```python
  my_tuple[0]
  #&gt; 1
  ```

- But when we try to modify a value, we get an error:

  ```python
  my_tuple[0] = 33
  #&gt; TypeError: ' tuple ' object does not support item assignment
  ```

---

## Methods for tuples

Because they can't be modified, tuples only have two methods:

- `count()` to count the number of occurrences of an element:

  ```python
  tt = (1, 1, 1, 1, 2, 2, 4)
  
  tt.count(1)
  #&gt; 4
  ```

- `index()` to return the index of the first occurrence of an element:
 
  ```python
  tt.index(2) 
  #&gt; 4
  ```

---
class: center middle inverse
name: sets

# Sets

-----

&lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt;

---

## Sets

**Sets are lists with no duplicate entries.**

- Sets can be created with curly braces `{}` &amp;mdash; like dictionaries (!),
  but the syntax of the elements will make clear which you mean:
  
  ```python
  set1 = {3, 4, 5, 6}
  ```

- However, we can't use just curly braces to create an *empty* set &amp;ndash;
  we can therefore only use `set()` to do so:
  
  ```python
  empty_set = set()
  ```

--

- In practice, it is common to create a set from a list &amp;ndash; this is a way
  to quickly *get all unique elements within a list*:
  
  ```python
  my_list = [5, 6, 7, 7, 7, 8, 9, 9]
  
  set2 = set(my_list)
  set2
  #&gt; {5, 6, 7, 8, 9}
  ```

---

## Intersecting two sets

We can use logical operators to look for shared and non-shared elements
between different lists:

- `setA &amp; setB` &amp;ndash; intersect: get elements present in *both sets*
- `setA | setB` &amp;ndash; union: get elements present in *at least one set*
- `setA ^ setB` &amp;ndash; symmetric difference: get elements present in *one set*
- `setA - setB` &amp;ndash; asymmetric difference: get elements only in `setA`
- `setB - setA` &amp;ndash; asymmetric difference: get elements only in `setB`

For example:

```python
#set1 = {3, 4, 5, 6}
#set2 = {5, 6, 7, 8, 9}

b &amp; c
#&gt; {5, 6}

b | c
#&gt; {3, 4, 5, 6, 7, 8, 9}

b ^ c
#&gt; {3, 4, 7, 8, 9}
```

---

## Intersecting two sets

&lt;figure&gt;
&lt;p align="center"&gt;
&lt;img src=img/sets.svg width="75%"&gt;
&lt;/p&gt;
&lt;/figure&gt;

---

## Methods to intersect two sets

- We can do the same operations with the methods `intersection()`,
  `union()`, `symmetric_difference()`, and `difference()`:
  
  ```python
  s1 = {1, 2, 3, 4}
  s2 = {4, 5, 6}
  
  s1.intersection(s2)         # Equivalent to: s1 &amp; s2
  #&gt; {4}
  
  s1.union(s2)                # Equivalent to: s1 | s2
  #&gt; {1, 2, 3, 4, 5, 6}
  
  s1.symmetric_difference(s2) # Equivalent to: s1 ^ s2
  #&gt; {1, 2, 3, 5, 6}
  
  s1.difference(s2)           # In set 1 but not in set 2
  #&gt; {1, 2, 3}
  
  s2.difference(s1)           # In set 2 but not in set 1
  #&gt; {5, 6}
  ```

---

## Methods to intersect two sets

We can also test whether sets are *subsets* or *supersets* of each other.

- Set 1 is a subset of set 2 if if s2 contains all its elements,
  and optionally others too:

  ```python
  # s1 = {1, 2, 3, 4}
  # s2 = {4, 5, 6}
  
  s1.issubset(s2)
  #&gt; False
  ```

- Set 1 is a superset of set 2 if set 1 contains all the elements in set 2,
  and optionally others too:
  
  ```python
  s1.issuperset(s2)
  #&gt; False
  ```

---

## Summary of data structures

| structure | bracket type   | create empty   | create non-empty
|-----------|----------------|----------------|--------
| **list**      | `[]`           | `[]`           | `[1, 2]`
| **dictionary**| `{}`           | `{}`           | `{1: "a", 2: "b"}`
| **tuple**     | `()`           | `()`           | `(1, 2)`
| **set**       | `{}`           | `set()`        | `{1, 2}`

&lt;br&gt;

--

```python
type([1, 2])
#&gt; list

type({1: "a", 2: "b"})
#&gt; dict

type((1, 2))
#&gt; tuple

type({1, 2})
#&gt; set
```

---

## Creating a convoluted data structure for practice

```python
# A tuple:
one = (1, 2, "tuple")

# A list:
two = [3, 4, "list"]

# A dictionary:
three = {5: ["value1"], 6: ["value2"]}

# A list containing the tuple, list, and dictionary:
container = [one, two, three]
container
#&gt; [(1, 2, 'tuple'), [3, 4, 'list'], {5: ['value1'], 6: ['value2']}]

# Append a value to dictionary ([2]), key [5]:
container[2][5].append("value3")
container
#&gt; [(1, 2, 'tuple'), [3, 4, 'list'],
#&gt; {5: ['value1', 'value3'], 6: ['value2']}]
```

---

## <i class="fas  fa-user-edit "></i> Intermezzo 3.2

1. Define a list `a = [1, 1, 2, 3, 5, 8]`.

2. Extract `[5, 8]` in two different ways.

3. Add the element 13 at the end of the list.

4. Reverse the list.

5. Define a dictionary `m = {"a": ".-", "b": "-...-", "c": '-.-.'}`.

6. Add the element `d` with value `-..`.

7. Update the value of `b` to be `-...`.

---

## <i class="fas  fa-user-edit "></i> Intermezzo 3.2: Solutions

1. Define a list:
  
   ```python
   a = [1, 1, 2, 3, 5, 8]
   ```

2. Extract `[5, 8]` in two ways:
   
   ```python
   a[4:6]
   a[-2:]
   ```
   
3. Add the element 13:

   ```python
   a.append(13)
   ```

4. Reverse the list:
   
   ```python
   a.reverse()
   a[::-1]
   ```

---

## <i class="fas  fa-user-edit "></i> Intermezzo 3.2: Solutions (cont.)

5\. Define a dictionary:
   
```python
m = "a": ".-", "b": "-...-", "c": "-.-."
```
   
6\. Add element `d`:

```python
m["d"] = "-.."
```

7\. Update element `b`:

```python
m["b"] = "-..."
```

---
class: center middle inverse

# Questions?

-----

&lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt;
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "rainbow",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
