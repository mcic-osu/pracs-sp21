---
title: "Week 11 - Python: Scientific computing"
output:
  xaringan::moon_reader:
    seal: false
    css: ["default", "default-fonts", "slides.css", "slides_copy.css"]
    lib_dir: libs
    nature:
      highlightStyle: rainbow
      highlightLines: true
      countIncrementalSlides: false
---
class:inverse middle center

```{r setup, include=FALSE}
options(htmltools.dir.version = FALSE)
knitr::opts_chunk$set(eval = FALSE)
```

```{r xaringan-extra, echo=FALSE, eval=TRUE}
#xaringanExtra::use_scribble()
#xaringanExtra::use_panelset()
#xaringanExtra::use_clipboard()
#xaringanExtra::use_search(show_icon = TRUE)
```

# *Week 11 - Python: Scientific computing*

----

# III: BioPython

<br> <br> <br> <br> <br>

### Jelmer Poelstra
### 2021/03/25 (updated: `r Sys.Date()`)

---

## What is BioPython?

BioPython is a project with a set of related modules to enable the
use of Python for various **bioinformatics tasks**, such as parsing and
processing bioinformatics file formats, access to online services like NCBI
Entrez and BLAST, and so on.

<br>

Today, we'll work through 4 small sample applications:

1. Finding and retrieving sequences from NCBI (CSB 6.4.1)

2. Reading and writing sequence data (CSB 6.4.2)

3. Programmatic BLAST search (CSB 6.4.3)

4. Querying PubMed (CSB 6.4.4)

---
class: center middle inverse

# BioPython (CSB 6.4)

-----

# I: Retrieving sequences from NCBI (6.4.1)

<br> <br> <br> <br>

---

## Using BioPython to inferface with NCBI databases

We already downloaded some data from NCBI manually in the exercises for
week 7 (Bioinformatics Data).

If we would regularly need to do so, or would need to download data from many
organisms, it would be much better to do this programmatically.

Luckily, we can use NCBI's **"Entrez Programming Utilities"** via 
the `Entrez` module in BioPython. 

--

<br>

- We start by importing the module &ndash; note that BioPython modules are
  imported using `from Bio import <focal-module>`:
  
  ```python
  from Bio import Entrez
  ```

- As another setup step,
  we should provide our e-mail address to let NCBI know who we are:

  ```python
  Entrez.email = "me.1@osu.edu"  # Replace by your email address
  ```

---

## The inquisitive shrew mole 

Let's say we would like to explore available DNA sequences from the Inquisitive
Shrew Mole, *Uropsilus investigator*.

<br>

<figure>
<p align="center">
<img src=img/inquisitive-shrew-mole.jpg width="55%">
<figcaption>The Inquisitive Shrew Mole is endemic to Yunnan, China. (<a href="https://theverybesttop10.com/rarest-species-of-moles-voles-and-shrews/">Image source</a>)</figcaption>
</p>
</figure>

---

## Perform the search

We can perform the search using the **`Entrez.esearch()`** function:

```python
handle = Entrez.esearch(db = "nuccore",
                        term = ("Uropsilus investigator[Organism]"),
                        retmax = 200)
```

  - NCBI makes several databases available through Entrez,
    and we searched the **"Nucleotide" (or `nuccore`) database**,
    which includes GenBank and RefSeq data, using the `db` argument.
  
  - We created a "handle" for the results
    (similar to *file handles* earlier).
  
  - For NCBI searches, we can narrow down results by adding keywords between square
    brackets, like `[Organism]`, after our search term.<sup>[1]</sup>
  
  - We set `RetMax` to 200 (default is 20) to get all the sequence identifiers
    (this can be a bit of trial-and-error or you can start veru high).

.footnote[<sup>[1]</sup>See the Nucleotide ["Advanced Search Builder"](https://www.ncbi.nlm.nih.gov/nuccore/advanced)
for all possible keywords.]

---

## Save and check the search results

- Read the results and close the search handle:

  ```python
  search_results = Entrez.read(handle)
  handle.close()
  ```

<br>

- Our results are returned in the form of a *dictionary*,
  so let's look at the keys:
  
  ```python
  search_results.keys()
  #> dict_keys(['Count', 'RetMax', 'RetStart', 'IdList',
  #>            'TranslationSet', 'TranslationStack',
  #>             'QueryTranslation'])
  ```
  
---

## Looking at the results

- How many sequences did we find?  
  
  ```python
  search_results["Count"]
  '126'   # Has increased from '71' in the book!
  ```
  
- What is the list of GenBank identifiers?

  ```python
  id_list = search_results["IdList"]
  
  print(id_list)
  #> ['524853022', '555947199', '555947198', ... , '555946814']
  
  len(id_list)   # Making sure we got all 126 IDs
  #> '126' 
  ```

---

## Downloading the sequences and <br> writing them to a FASTA file

- We'll now use the retrieved GenBank IDs (`id = id_list`) to download the
  sequences in FASTA format (`rettype = "fasta"`):

  ```python
  search_handle = Entrez.efetch(db = "nuccore",
                                  rettype = "fasta",
                                  id = id_list)
  ```

--

- Next, we can write the sequences to file:

  ```python
  with open("Uropsilus_seq.fasta", "w") as fhandle_out:
         for line in search_handle:
             fhandle_out.write(line)
  search_handle.close()
  ```

<br>

- **The next step is to read our FASTA file back in, properly parsed,
  using the `SeqIO` module.**

---

class: center middle inverse

# BioPython (CSB 6.4)

-----

# II: Reading and writing sequence data <br> using *SeqIO* (6.4.2)

<br> <br> <br> <br>

---

## Reading a FASTA file with SeqIO

- We start by importing the BioPython `SeqIO` module:

  ```python
  from Bio import SeqIO
  ```

<br>

- With `SeqIO.parse()`, we can create an object called a `SeqRecord` iterator
  that we can then loop over to retrieve our sequences.
  
  ```python
  records = SeqIO.parse("Uropsilus_seq.fasta", "fasta")
  ```
  
  This model is similar to the *file handles* we worked with earlier and is
  particularly useful for very large FASTA files,
  so we don't have to load them into memory.
  
---

## Reading a FASTA file with SeqIO (cont.)

- Each FASTA record has several attributes, including:
  - `description` &ndash; everything after the `>`
  - `name` &ndash; first word after the `>`
  - `seq` &ndash; the sequence

<br>

<p align="center">
<img src=img/FASTA.png width="100%">
</p>

---

## Reading a FASTA file with SeqIO (cont.)

- For each record, let's print the `description` and the length (in bp)
  of `seq`:

  ```python
  for record in records:
        print(record.description, '\n', len(record.seq), '\n')
  
  #> KC516837.1 Uropsilus investigator isolate A11 apolipoprotein B (ApoB) gene, partial cds
  #> 573 
  #>
  #> KC516819.1 Uropsilus investigator voucher mlxs331 cytochrome c oxidase subunit I (COI) gene, partial cds, alternatively spliced; mitochondrial
  #> 912 
  #>
  #> KC516818.1 Uropsilus investigator voucher mlxs022 cytochrome c oxidase subunit I (COI) gene, partial cds, alternatively spliced; mitochondrial
  #> 912 
  #> [...]
  ```

---

## Selecting only sequences for the BMI1 genes

Next, say that we to:
  - Select only records originating from a specific gene
  - Only take the first 100 bp of sequence for each record

<br>

.content-box-info[
This is a quite apt example because parsing and subsetting FASTA files
with *shell tools* is not as easy as you may expect.

This is because each FASTA record spans multiple lines &ndash;
and the *sequence* for an individual records may or
may not itself also be spread across multiple lines.
]

---

## Selecting only sequences for the BMI1 genes

Next, say that we to:
  - Select only records originating from a specific gene
  - Only take the first 100 bp of sequence for each record

```python
output_handle = open("Uropsilus_BMI1.fasta", "w")

for record in SeqIO.parse("Uropsilus_seq.fasta", "fasta"):
    
    if record.description.find("BMI1") != -1:
        print(record.id)
        short_seq = record[:100]  # Take the first 100 bases
        SeqIO.write(short_seq, output_handle, "fasta")
        
output_handle.close()
```

We used the string method `find()` to match "*BMI1*",
making use of the fact that it returns `-1` when no match is found.

--

.content-box-info[
Next week, we'll learn how to use the
regular expression module `re` to do this more gracefully and flexibly.
]

---

class: center middle inverse

# BioPython (CSB 6.4)

-----

# III: Programmatic BLAST search (6.4.3)

<br> <br> <br> <br>

---

## NCBI BLAST

The **Basic Local Alignment Search Tool (BLAST)** finds regions of similarity
between biological sequences,
and is one of the most widely used bioinformatics tools.

You may know it by its web interface, where you can paste in or upload some
sequences, and then "BLAST them" against a database you can specify.

<figure>
<p align="center">
<img src=img/blast_screenshot.png width="80%">
<figcaption>Screenshot from <a href="https://blast.ncbi.nlm.nih.gov/Blast.cgi?PROGRAM=blastn&PAGE_TYPE=BlastSearch&LINK_LOC=blasthome">NCBI BLAST</a>.</figcaption>
</p>
</figure>

---

## Getting set up for BLAST with the Blast module

Using the web interface may be convenient when you just have one or a few sequences,
but it is not very reproducible, tedious to repeat, and unsuitable for automation.

Luckily, Biopython provides the module `Bio.Blast` which we can use to run a
BLAST search against the NCBI's online databases programmatically.<sup>[1]</sup>

.footnote[
<sup>[1]</sup> Note, there is also a *command-line* BLAST tool.
]

--

```python
# from Bio import SeqIO   # Should already be loaded
# from Bio import Entrez  # Should already be loaded
from Bio.Blast import NCBIWWW, NCBIXML
```

We imported just two of its functions:
  
  - `NCBIWWW` for access to NCBI's BLAST server &ndash;
     the BLAST analysis is still being performed there.
  
  - `NCBIXML` to parse the XML format in which our results will be returned.

---

## Storing all FASTA records in a list

We will start by parsing our FASTA file again with `SeqIO`.

This time, however, we will read the entire file into memory at once
by converting the `SeqRecord` iterator to a list:

```python
records = list(SeqIO.parse("Uropsilus_BMI1.fasta", "fasta"))
```

--

What does this list look like? Let's print the first 2 items:

```python
records[0:2]
#> [SeqRecord(seq=Seq('TATTATGCTGTTTTGTGAACCTGTAGAAAACAAGTGCTTTTTATCTTGAAATTC...CCA', SingleLetterAlphabet()), id='KF778086.1', name='KF778086.1', description="KF778086.1 Uropsilus investigator voucher KIZ:020539 polycomb ring finger oncoprotein (BMI1) gene, 3' UTR", dbxrefs=[]),
#> SeqRecord(seq=Seq('TATTATGCTGTTTTGTGAACCTGTAGAAAACAAGTGCTTTTTATCTTGAAATTC...CCA', SingleLetterAlphabet()), id='KF778085.1', name='KF778085.1', description="KF778085.1 Uropsilus investigator voucher KIZ:020527 polycomb ring finger oncoprotein (BMI1) gene, 3' UTR", dbxrefs=[])]
```

From this list, we can still extract record attributes &ndash;
for instance, we can print the `id` and `seq` for the 4th record:

```python
print(records[3].id, " ", records[3].seq)
#> KF778083.1   TATTATGCTGTTTTGTGAACCTGTAGAAAACAAGTGCTTTTTATCTTGAAATTCAACAAATGGAAAGAATATGCATAGAATAATGCATTCTATGTAGCCA
```

---

## Run the BLAST search

For our BLAST search, we will use the nucleotide database (`nt`)
with the `blastn` algorithm, the BLAST variant for standard nucleotide to
nucleotide searches (other options are `blastp`, `blastx`, `tblastn`, and `tblastx`).

<br>

The `qblast()` function requires three arguments:
  - The program &ndash; `blastn` for us
  - The database &ndash; `nt` for us
  - The query sequence &ndash; the 4th record from our FASTA file

```python
Entrez.email = "me.999@osu.edu"

result_handle = NCBIWWW.qblast("blastn", "nt", records[3].seq)
```

---

## Write the results to a file

Now, we will write our results, which are in XML format,
to a file, and then close the result handle:

```python
with open("my_blast.xml", "w") as fhandle:
    fhandle.write(result_handle.read())

result_handle.close()
```

---

## Parse the XML file

We will parse our XML file with BLAST results using the `NCBIXML`
parser:<sup>[1]</sup>

.footnote[<sup>[1]</sup> Because we our query consisted only of a single sequence,
we could use `NCBIXML.read()`. For multiple sequences, you should use `NCBIXML.parse`.]

```python
result_handle = open("my_blast.xml")
blast_records = NCBIXML.read(result_handle)
```

---

## Processing the BLAST results

Next, we loop through the individual alignment hits and then for each hit
through the "High-Scoring Pairs" (HSPs, subsequences with a good match).

For each High-Scoring Pair, we check whether the match is good enough
according to an arbitrary E-value (`E_VALUE_THRESH`) and length (`LEN_THRESH`)
that we set.

```python
E_VALUE_THRESH = 0.04
LEN_THRESH = 3000

for align in blast_records.alignments:
    
    for hsp in align.hsps:
        
        if hsp.expect < E_VALUE_THRESH and align.length > LEN_THRESH:
            
            print("****Alignment****")
            print("sequence:", alignment.title)
            print("length:", alignment.length)
            print("E value:", hsp.expect)
            print(hsp.query[0:75] + "...")
            print(hsp.match[0:75] + "...")
            print(hsp.sbjct[0:75] + "...")
```

---

## Processing the BLAST results

```python
E_VALUE_THRESH = 0.04
LEN_THRESH = 3000

for align in blast_records.alignments:
    
    for hsp in align.hsps:
        
        if hsp.expect < E_VALUE_THRESH and align.length > LEN_THRESH:
            
            print("****Alignment****")
            print("sequence:", alignment.title)
            print("length:", alignment.length)
            print("E value:", hsp.expect)
            print(hsp.query[0:75] + "...")
            print(hsp.match[0:75] + "...")
            print(hsp.sbjct[0:75] + "...")
#> ****Alignment****
#> sequence: gi|1304911126|ref|XM_006933246.4| PREDICTED: Felis catus BMI1 proto-oncogene, polycomb ring finger (BMI1), transcript variant X3, mRNA
#> length: 3523
#> E value: 2.25861e-42
#> TATTATGCTGTTTTGTGAACCTGTAGAAAACAAGTGCTTTTTATC...
#> |||||||||||||||||||||||||||||||||||||||||||||...
#> TATTATGCTGTTTTGTGAACCTGTAGAAAACAAGTGCTTTTTATC...
#> [...]
```

---

class: center middle inverse

# BioPython (CSB 6.4)

-----

# IV: Querying PubMed (6.4.4)

<br> <br> <br> <br>

---

## PubMed search

Using the `Entrez.esearch()` function we saw earlier,
we can search any NCBI database,
including PubMed, which contains scientific literature.

By way of example, we will search for any papers on *Drosophila* that mention
the gene "*spaetzle*" anywhere in the title or abstract:<sup>[1]</sup>

.footnote[<sup>[1]</sup>See [here](https://pubmed.ncbi.nlm.nih.gov/help/#author-search)
for PubMed search options.]

```python
from Bio import Entrez
Entrez.email = "me.999@osu.edu"

handle = Entrez.esearch(db = "pubmed",
                        term = ("spaetzle[Title/Abstract] AND Drosophila[ALL]"),
                        usehistory = "y")
record = Entrez.read(handle)
handle.close()                        
```                        

---

## PubMed search

Using the `Entrez.esearch()` function we saw earlier,
we can search any NCBI database,
including PubMed, which contains scientific literature.

By way of example, we will search for any papers on *Drosophila* that mention
the gene "*spaetzle*" anywhere in the title or abstract:<sup>[1]</sup>

```python
from Bio import Entrez
Entrez.email = "me.999@osu.edu"

handle = Entrez.esearch(db = "pubmed",
                        term = ("spaetzle[Title/Abstract] AND Drosophila[ALL]"),
                        usehistory = "y")
record = Entrez.read(handle)
handle.close()                        
```                        

- We used `usehistory = "y"`, which will allows us to refer back to our search
  to fetch the titles and abstracts by saving `WebEnv` and `QueryKey`:

  ```python
  webenv = record["WebEnv"]
  query_key = record["QueryKey"]
  ```

---

## PubMed search (cont.)

- How many hits did we get?

  ```python
  record["Count"]
  #> '15'
  ```
  
  We found 15 records (up from 13 in the book) that contained the words
  "*spaetzle*" and "*Drosophila*".

--

- We can now fetch the titles and abstracts:

  ```python
  handle = Entrez.efetch(db = "pubmed",
                           rettype = "medline", retmode = "text",
                           webenv = webenv, query_key = query_key)
  data = handle.read()
  handle.close() 
  ```

--

- Finally, we write the results to file:

  ```python
  out_handle = open("Spaetzle_abstracts.txt", "w")
  out_handle.write(data)
  out_handle.close()
  ```

---

## PubMed search (cont.)

- Let's have a look at the results:

  ```python
  !cat Spaetzle_abstracts.txt
  ```
  
- With a simply `grep` command, we can just see lines
  (and some context with `-C 1`) with the word "*Spaetzle*":  

  ```python
  !grep -i "spaetzle" -C 1 Spaetzle_abstracts.txt
  
  #>     leading to ventrally-restricted expression of the sulfotransferase Pipe. These
  #>    events promote the ventral processing of Spaetzle, a ligand for Toll, which
  #>    ultimately sets up the embryonic dorsal-ventral axis. We then describe the
  #> --
  #> DP  - 2019 Nov 12
  #> TI  - Dynamics of Spaetzle morphogen shuttling in the Drosophila embryo shapes
  #>    gastrulation patterning.
  #> --
  #>    The dynamics indicate that a sharp extracellular gradient is formed through
  #>    diffusion-based shuttling of the Spaetzle (Spz) morphogen that progresses through
  #>    several nuclear divisions. Perturbed shuttling in wntD mutant embryos results in 
  ```

---

## PubMed search (cont.)

Alternatively, we could use regular expressions in Python to nicely get each
*sentence* with "*Spaetzle*" along with the PubMedID for the publication:

```python
import re
with open("Spaetzle_abstracts.txt") as datafile:
    
    pubmed_input = datafile.read()
    # Titles and abstracts on one line: delete newlines + 6 spaces:
    pubmed_input = re.sub(r"\n\s{6}", " ", pubmed_input)

    for line in pubmed_input.split("\n"):
        if re.match("PMID", line):
            PMID = re.search(r"\d+", line).group()
        if re.match("AB", line):
            spaetzle = re.findall(r"([^.]*?Spaetzle[^.]*\.)", line)
            if spaetzle:
                print("PubMedID: ", PMID, " ", spaetzle)
#> PubMedID:  32591083   [' These events promote the ventral processing of Spaetzle, a ligand for Toll, which ultimately sets up the embryonic dorsal-ventral axis.']
#> PubMedID:  31719046   ['  The dynamics indicate that a sharp extracellular gradient is formed through diffusion-based shuttling of the Spaetzle (Spz) morphogen that progresses through several nuclear divisions.']
#> PubMedID:  27314646   [' While cytokines activating immune responses,  such as Spaetzle or Unpaired-3, have been identified and
```  
  
**We will learn how to do this next week!**

---

## PubMed search (cont.)

While this PubMed search was relatively trivial, you may need to do this kind of
search for a dozen or more genes, and possibly repeat the search periodically.

In that case, using Python to do the searches and parse the results can be a
huge time-saver!

---
class: center middle inverse

# Questions?

-----

<br> <br> <br> <br>
