---
title: "Graded Assignment II: Shell scripts at OSC"
output:
  distill::distill_article:
    self_contained: false
    toc: true
    toc_depth: 3
---

<br>

## Introduction

If you did last week's exercises, much of the following description will be familiar to you (but this time around, you will remove the primer sequences using the software Cutadapt, whereas in last week's exercises, you just looked for their presence).

This assignment will work with 6 [FASTQ files](https://support.illumina.com/bulletins/2016/04/fastq-files-explained.html) with sequences from the V4 region of 16S rRNA, generated in a metabarcoding experiment.

The FASTQ files come in pairs: for every sample, there is a FASTQ file with *forward reads* (or "read 1" reads) that contains `_R1_` in its file name, and a FASTQ file with corresponding *reverse* reads (or "read 2" reads) that contain `_R2_` in its file name. So, our 6 FASTQ files consist of 3 pairs of files with forward and reverse reads for 3 different biological samples.

The sequences were generated by first amplifying environmental samples with a pair of universal 16S primers, and these primer sequences are expected to be present in the FASTQ sequences. **You will remove these primer sequences with the program Cutadapt**, and there are two things to be aware of:

-   A primer can also be present in the FASTQ sequence as its *reverse complement*, so we will search for reverse complements too.
-   The primers contain a few variable sites, which are indicated using *ambiguity codes*. For instance, an `R` means that the site can be either an `A` or a `G`, and an `N` means that the site can be any of the four bases. See [here](https://droog.gs.washington.edu/parc/images/iupac.html) for a complete overview of these ambiguity codes.

These are the primer sequences:

-   Forward primer ("515F"): `GAGTGYCAGCMGCCGCGGTAA`.
-   Reverse primer ("806R"): `TTACCGCGGCKGCTGRCACTC`.

### Grading information

-   ....

### General information

-   For each numbered step below, you should create *at least* one Git commit.

<br>

## Getting set up

1.  Create a new dir for this assignment, and inside it, initialize a Git repository.

2.  Copy the FASTQ files from `/fs/ess/PAS1855/data/week05/fastq` into a directory `data/fastq/` inside your assignment's directory.

3.  Create a `.gitignore` file and add a line to make Git ignore all `.fastq` files.

4.  Create a `conda` environment for Cutadapt.\
    Export the environment description to a `.yml` file. *\
    *ADD INSTRUCTIONS OR LET THEM LOAD MY ENV.

<br>

## A script to run Cutadapt on one pair of FASTQ files

Now, you should write a script called `cutadapt_single.sh` that runs Cutadapt for one sample i.e. one pair of FASTQ sequences: one with forward (`R1`) reads and one with reverse (`R2`) reads for the sample.

3.  Start with the rather extensive header that will be necessary: the *shebang* line, SLURM directives, `set` settings for robust scripts, and loading the `conda` module and the Cutadapt `conda` environment.

    Use at least the following SLURM directives:

    -   The class's OSC project number.
    -   A 20-minute wall-time limit.
    -   Explicitly ask for one node, one process (task), and one core (these are three separate directives).

4.  Let the script take 4 arguments that can be passed to it on the command-line:

    -   The path to a FASTQ file with forward reads (whose value when passed from the command-line will e.g. be `data/fastq/201-S4-V4-V5_S53_L001_R1_001.fastq`).
    -   The name of the output directory for trimmed FASTQ files (whose value will be a name that you pick, but e.g. `results/trim`).
    -   The sequence of the forward primer to be removed (whose value will be `GAGTGYCAGCMGCCGCGGTAA`).
    -   The sequence of the reverse primer to be removed (whose value will be `TTACCGCGGCKGCTGRCACTC`).

    Give each of these variables a descriptive name rather than directly using the placeholder variables (`$1`, etc) -- that will make your life a lot easier when writing the rest of the script.

5.  Compute the *reverse complements* of both of the primers. Use `tr` to compute the complement and then pipe this into `rev` (a command we haven't seen yet; but you can simply use `rev` with no options). Make sure you don't just translate `ACTG` but also take all the possible IUPAC ambiguity codes into account! See [here](https://droog.gs.washington.edu/parc/images/iupac.html) for a complete overview of these ambiguity codes.

    <details>

    <summary>Hints</summary>

    <p>

    Use command substitution to save the reverse complement primer sequences.

    Do some testing of your commands to see if the reverse complements come out correctly!

    </p>

    </details>

6.  From the file name of the input FASTQ file with forward reads (which is one of the arguments to the script), infer the name of the corresponding FASTQ file with reverse reads, which will have an identical name except that `_R1_` is replaced by `_R2_`.

7.  Assign output file paths (output dir + file name) for the `R1` and `R2` output file, inserting `_trimmed` before the file extension, which you can assume to be `.fastq`. (I.e., the output file paths should be along the lines of `<output-dir>/<old-file-name>_trimmed.fastq`).\
    \
    You'll do yourself a favor by having the script `echo` the file names that you have assigned, so you can easily check if you're doing this right.

    <details>

    <summary>Hints</summary>

    <p>

    \
    Test that you're getting all the file names right! To do so, assign one of the paths to the actual FASTQ files to the variable name you're using for that, and ditto with an output dir (in your shell but not in the script -- at least, these test assignments should not end up in your final script!).

    </p>

    </details>

8.  Create the output dir if it doesn't already exist.

9.  The actual call to the Cutadapt program should be as follows (change variable names if needed!):

    ``` {.bash}
    $ cutadapt -a "$primer_f"..."$primer_r_revcomp" \
        -A "$primer_r"..."$primer_f_revcomp" \
        --discard-untrimmed --pair-filter=any \
        -o "$R1_out" -p "$R2_out" "$R1_in" "$R2_in"
    ```

10. Make the script executable and submit the script as a SLURM job. Check the SLURM log file and the output files. If it didn't work, troubleshoot until you get it working.

*Optional (ungraded): Touch up the scripts with `echo` statements, `date` commands, and tests such as whether 4 arguments were provided.*

<br>

## Finishing up

12. Do any necessary cleaning up of files, e.g. move your SLURM log file to an appropriate place, and make sure everything is committed to the Git repository.
13. Create a GitHub repository and push your local repo on line. Like last time, tag `@jelmerp` in an issue.

<br>

## *Optional (ungraded) - A script to loop over all samples*

*Creating a script like we did above only makes sense if we plan to run it for many samples. Now, you will create a second script `cutadapt_submit.sh` that loops over all FASTQ files in a specified directory. It doesn't need to be a "proper" script with a robust header, and so on, and shouldn't contain any SLURM directives: this script only functions to* submit *SLURM jobs and can be run interactively.*

14. *Loop over a globbing pattern that accepts all `.fastq` files with `R1` in the name in the input directory (we don't want the `R2` files included as they will be automatically added in our previous script).*
15. *Inside the loop, the `cutadapt_single.sh` script should be submitted as a SLURM job, similar to your single submission of the script above.*
16. *Run the loop.*
17. *Check the SLURM log files and the output directory. If it didn't work, remove all these files, troubleshoot, and try again until it is working.*
