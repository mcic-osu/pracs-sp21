---
title: "Exercises: Week 8"
output:
  distill::distill_article:
    self_contained: false
    toc: true
    toc_depth: 3
---

```{r}
knitr::opts_chunk$set(echo = TRUE)
```

## Setup

-   Open a new file and save it as `week08_exercises.py` or something along
    those lines.

-   Type your commands in the script and send them to the prompt in the Python interactive window by pressing <kbd>Shift</kbd>+<kbd>Enter</kbd>.

    <details>

    <summary>Problems with the keyboard shortcut?</summary>\
    If this doesn't work, check your keyboard shortcut by right-clicking in the script and looking for "Run Selection/Line In Python Interactive Window".\
    \
    Also, you can open the Command Palette (<kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>P</kbd>) and look for that shortcut there, and change it if you want.

    </details>

-   Because these exercises have many small steps, I put the solutions right below the question, so you don't have to scroll back-and-forth all the time. *However*, make sure you actually try to do the exercises!

<br>

## Exercise 1: Variable types and strings

1.  Print the type of the value `4.88`.\

    <details>

    <summary>Solution</summary>

    We can use the function `type()`:

    ```{python}
    type(4.88)
    ```
    
    The result would be the same if we first assigned it as a variable:
    ```{python}
    num = 4.88
    type(num)
    ```

    </details>

2.  Assign the variable `n_samples = 658`, and then extract the third character from `n_samples`.

    <details>

    <summary>Hints</summary>\
    You can't index a number like `n_samples[index]`, so you'll first have to convert `n_samples` to a string. Also, recall that Python starts counting from 0!

    </details>

    <details>

    <summary>Solution</summary>

    ```{python}
    n_samples = 658
    str(n_samples)[2]
    ```

    </details>

3.  Assign the string 'CTTATGGAAT' to a variable called `adapter`. Print the number of characters in `adapter`.\

    <details>

    <summary>Solution</summary>

    ```{python}
    adapter = 'CTTATGGAAT'
    len(adapter)
    ```

    </details>

4.  Replace all `A`s by `N`s in `adapter` and assign the resulting string to a new variable. Print the new variable.\
    
    <details>

    <summary>Hints</summary>\
    Use the string method `replace()`, and recall that methods are called using
    the `<object_name>.<method_name>()` syntax.

    </details>

    <details>

    <summary>Solution</summary>

    ```{python}
    bad_seq = adapter.replace('A', 'N')
    bad_seq
    ```

    </details>

5.  Find out what the third argument to the `replace()` method does by using the built-in help.\

    <details>

    <summary>Hints</summary>\
    If you are typing your commands in a script rather than straight in the console, you will get some more information already when typing the opening parenthesis of the method (briefly pause if necessary).\
    \
    To get more help, you can use a notation with a `?`, or `help(object.method)`.

    </details>

    <details>

    <summary>Solution</summary>

    ```{python}
    help(adapter.replace)
    # Or: "adapter.replace?"
    # Or: "?adapter.replace"
    ```

    As it turns out, the third argument, `count`, determines how many instances of the substring will be replaced.\

    </details>

6.  Using what you found out in the previous steps, replace just the first two `A`s in `adapter` by `N`s.\

    <details>

    <summary>Solution</summary>\
    We specify `2` as the third argument, which is the number of instances of the substring that will be replaced:

    ```{python}
    adapter.replace('A', 'N', 2)
    ```

    </details>

7.  Convert the following strings and numbers to a Boolean value to see what the resulting Boolean is (True or False): `"False"` (with quotes), `0`, `1`, `-1`, `""`, `None`, and see if you can make sense of these results.\

    <details>

    <summary>Solution</summary>

    ```{python}
    bool("False")
    ```

    ```{python}
    bool(1)
    ```

    ```{python}
    bool(0)
    ```

    ```{python}
    bool(-1)
    ```

    As it turns out, among numbers and strings, *only* 0 is interpreted as `False`,
    whereas *anything else* is interpreted as `True`.

    ```{python}
    bool("")
    ```

    ```{python}
    bool()
    ```

    ```{python}
    bool(None)
    ```
    
    But an empty string, nothing at all between parenthesis, and `None` (Python's keyword to define a null     value or the lack of a value), are also interpreted as `False`.
    
    Note that as soon as you quote `"None"`, it is a string again and will be interpreted as `True`:

    ```{python}
    bool("None")
    ```

    </details>

8.  Have a look at the names of the methods that appear when you type `adapter.` (note the `.`). Can you find a method that will print the *last* occurrence of a `T` in `adapter`?\

    <details>

    <summary>Hints</summary>\
    The method `rfind` will search from the right-hand side (hence `r`), and will therefore print the last occurrence of the specified substring.

    </details>

    <details>

    <summary>Solution</summary>

    ```{python}
    adapter.rfind("T")
    ```

    </details>

9. Split the sequence by `GAGTCCCTNNNAGCAACGTTNNTTCGTCATTAN` by `N`s.\

    <details>
    
    <summary>Hints</summary>\
    Use the `split()` method for strings.

    </details>

    <details>

    <summary>Solution</summary>

    ```{python}
    seq = "GAGTCCCTNNNAGCAACGTTNNTTCGTCATTAN"
    split_seq = seq.split('N')
    split_seq
    ```

    </details>

<br>

## Exercise 2: Lists

1.  Assign a list `plant_diseases` that contains the items `fruit_rot`, `leaf_blight`, `leaf_spots`, `stem_blight`, `canker`, `wilt`, `root_knot` and `root_rot`.\

    <details>

    <summary>Solution</summary>

    ```{python}
    diseases = ['fruit_rot', 'leaf_blight', 'leaf_spots', 'stem_blight',
                'canker', 'wilt', 'root_knot', 'root_rot']
    ```

    </details>

2.  Extract `stem_blight` from `diseases` by its index (position).\

    <details>

    <summary>Solution</summary>\
    `stem_blight` is the fourth item and because Python starts counting at 0, this is index number 3.

    ```{python}
    diseases[3]
    ```

    </details>

3.  Extract the first 5 items from `diseases`.\

    <details>

    <summary>Hints</summary>\
    Recall that when using ranges, Python does *not* include the item corresponding to the last index.

    </details>

    <details>

    <summary>Solution</summary>\
    While index 5 is the *sixth* item, it is not included, so we specify `0:5` or `:5` to extract elements up to and including the fifth one:

    ```{python}
    diseases[0:5]
    ```

    Or:

    ```{python}
    diseases[:5]
    ```

    </details>

4.  Extract the last item from `diseases`.\

    <details>

    <summary>Hints</summary>\
    Recall that you can use negative numbers to start counting from the end.
    Also, while `0` is the first index, "-0" (or something along those lines)
    is *not* the last index.

    </details>

    <details>

    <summary>Solution</summary>

    ```{python}
    diseases[-1]
    ```

    </details>

5.  Extract the last 3 items from `diseases`.\

    <details>

    <summary>Solution</summary>\
    Note that you'll *have to* omit a number after the colon in this case, because `[-3:-1]` would not include the last number, and `[-3:0]` does not work either.

    ```{python}
    diseases[-3:]
    ```

    </details>

6.  If you would run:

    ```{python, eval=FALSE}
    more_diseases = diseases

    more_diseases.append("crown_galls")
    ```

    Would the list `diseases` contain `crown_galls`? Think about what the answer should be, and then check if you were right.\

    <details>

    <summary>Solution</summary>\
    Yes, `diseases` will contain the item `crown_galls` that was added to `more_diseases`, because `more_diseases` in not an independent list but is merely a second pointer to the same list that `diseases` points to.

    ```{python}
    more_diseases = diseases

    more_diseases.append("crown_galls")

    diseases
    ```

    </details>

7.  Copy `diseases` to a new list with a name of your choice -- the new list should *not* be linked to `diseases`. Then, remove all items from the new list. Check if `diseases` still contains its items -- if not, you'll have to try again!\

    <details>

    <summary>Hints</summary>\
    To create a copy, use the `copy()` method or the `[:]` notation.

    </details>

    <details>

    <summary>Solution</summary>\
    To create a copy, use the `copy()` method:

    ```{python}
    diseases_copy = diseases.copy()
    ```

    Or the `[:]` notation.

    ```{python}
    diseases_copy = diseases[:]
    ```

    Then, to remove all elements in the copy of the list:

    ```{python}
    diseases_copy.clear()

    diseases
    ```

    </details>

8.  What fundamental difference between lists and strings makes it so that `newstring = oldstring` creates *a new string*, whereas `newlist = oldlist` simply creates a new *pointer to the same list*?\

    <details>

    <summary>Solution</summary>\
    The fact that strings are *immutable*, whereas lists are *mutable*.

    </details>

9.  Sort `diseases` in place.\

    <details>

    <summary>Solution</summary>\
    Recall that `sort()` sorts in place, whereas `sorted()` returns a new, sorted list.

    ```{python}
    diseases.sort()

    diseases
    ```

    </details>

10. Find out how you can use the `sorted()` function to sort in reverse order, and apply this to `diseases` to create a new list `diseases_sorted`.\

    <details>

    <summary>Solution</summary>\
    We can use the `reverse` argument to `sorted()` to sort in reverse order:

    ```{python}
    diseases_sorted = sorted(diseases, reverse=True)
    ```

    </details>

11. ***Bonus:*** If you would run `fewer_diseases = diseases.remove("root_rot")`, what would `fewer_diseases` contain? Think about what the answer should be, and then check if you were right. Does simply running `fewer_diseases` versus running `print(fewer_diseases)` make a difference?\

    <details>

    <summary>Solution</summary>
    
    Because `remove()` operates *in place*, it doesn't return anything:
    
    ```{python}
    fewer_diseases = diseases.remove("root_rot")

    fewer_diseases
    ```

    Well, it actualy returns `None`, which you can see by explicitly calling
    the `print()` function:
    
    ```{python}
    print(fewer_diseases)
    ```

    </details>

12. ***Bonus:*** Get all unique *characters* (not items) present in `diseases`.\

    <details>

    <summary>Hints</summary>\
    Remember how we can turn a list into a string with `join()`? If you specify `""` as the separator, it will simply concatenate all the items in the list.\
    \
    Also, using `set()` on a string will extract the unique characters.

    </details>

    <details>

    <summary>Solution</summary>\
    First, turn the list into a string using `"".join`. Then, call `set()` on the string to get a list of unique items (= characters).

    ```{python}
    set("".join(diseases))
    ```

    </details>

<br>

## Exercise 3: Dictionaries

1.  Create and print a dictionary called `yield_current` with the following items:

    ``` {.python}
    {"plotA_1": 12, "plotA_2": 18, "plotA_3": 2,
     "plotB_1": 33, "plotB_2": 28, "plotB_3": 57}
    ```

    <details>

    <summary>Solution</summary>

    ```{python}
    yield_current = {"plotA_1": 12, "plotA_2": 18, "plotA_3": 2,
                     "plotB_1": 33, "plotB_2": 28, "plotB_3": 57}
                     
    yield_current                 
    ```

    </details>

2.  Print just the value for key `plotA_3`.

    <details>

    <summary>Solution</summary>\
    We can get the value for a specific key using the `<dict>[<key>]` notation:

    ```{python}
    yield_current["plotA_3"]
    ```

    </details>

3.  Can you select a dictionary item by position (index)? Why / why not?\

    <details>

    <summary>Solution</summary>\
    No, because dictionaries have no order to them.

    </details>

4.  Update the value for key `plotB_2` to be `31` and check whether this worked.

    <details>

    <summary>Solution</summary>\
    We can simply assign a new value using `=`:

    ```{python}
    yield_current["plotB_2"] = 31
    yield_current["plotB_2"]
    ```

    </details>

5.  Count the number of items (i.e. entries, key-value *pairs*) in your dictionary.\

    <details>

    <summary>Hints</summary>\
    Use the `len()` function.

    </details>

    <details>

    <summary>Solution</summary>

    ```{python}
    len(yield_current)
    ```

    </details>

6.  ***Bonus:*** Create a dictionary `obs_20210305` with keys `plotA_3` and `plotC_1`,
    and values `18` and `3`, respectively.
    Then, update the `yield_current` dictionary with the `obs_20210305` dictionary,
    and check whether this worked.\

    <details>

    <summary>Solution</summary>

    ```{python}
    obs_20210305 = {"plotA_3": 18, "plotC_1": 3}
    ```

    We use the `update()` method as follows:

    ```{python}
    yield_current.update(obs_20210305)

    yield_current
    ```
    
    Now, our dictionary has an updated value for key "plotA_3",
    and an entirely new item with key "plotC_1".
    
    </details>

7.  ***Bonus:*** Get and count the number of *unique values* in your dictionary.\

    <details>

    <summary>Hints</summary>\
    Extract the values with the `values()` method.
    Turn these values into a set to get the unique values.
    Count the unique values with the `len()` function.

    </details>

    <details>

    <summary>Solution</summary>

    ```{python}
    len(set(yield_current.values()))
    ```

    </details>

<br>

## Exercise 4: Sets

1.  Assign a set named `dna` with 4 items: each of the 4 bases (single-letter abbreviations) in DNA.\

    <details>

    <summary>Hints</summary>\
    Recall the use of curly braces to assign a set.

    </details>

    <details>

    \
    <summary>Solution</summary>

    ```{python}
    dna = {'A', 'G', 'C', 'T'}
    ```

    </details>

2.  Assign a set named `rna` with 4 items: each of the 4 bases (single-letter abbreviations) in RNA.\

    <details>

    <summary>Solution</summary>

    ```{python}
    rna = {'A', 'G', 'C', 'U'}
    ```

    </details>

3.  Find the 3 bases that are shared between DNA and in RNA
    (try both with an operator and a method, if you want).\

    <details>

    <summary>Solution</summary>

    ```{python}
    dna & rna
    ```

    Or:

    ```{python}
    dna.intersection(rna)
    ```

    </details>

4.  Find all 5 bases that are collectively found among DNA and RNA.

    <details>

    \
    <summary>Solution</summary>

    ```{python}
    dna | rna
    ```

    Or:

    ```{python}
    dna.union(rna)
    ```

    </details>

5.  Find the base that only occurs in DNA.

    <details>

    <summary>Solution</summary>

    ```{python}
    dna - rna
    ```

    Or:

    ```{python}
    rna.difference(dna)
    ```

    </details>

6.  Assign a set named `purines` with the two purine bases and a set named `pyrimidines` with the three pyrimidine bases.\

    <details>

    <summary>Solution</summary>

    ```{python}
    purines = {'A', 'G'}
    pyrimidines = {'C', 'T', 'U'}
    ```

    </details>

7.  Find the pyrimidine that occurs both in RNA and DNA.\

    <details>

    <summary>Solution</summary>\
    You can combine more than two sets either by chaining methods or adding
    another operator.

    </details>

    <details>

    <summary>Solution</summary>

    ```{python}
    pyrimidines & dna & rna
    ```

    Or:

    ```{python}
    pyrimidines.intersection(dna).intersection(rna)
    ```

    </details>

8.  ***Bonus:*** Find the pyrimidine that occurs in RNA but not DNA.\

    <details>

    <summary>Solution</summary>

    ```{python}
    (rna - dna) & pyrimidines
    ```

    Or:

    ```{python}
    rna - dna & pyrimidines
    ```

    Or:

    ```{python}
    rna.difference(dna).intersection(pyrimidines)
    ```

    </details>

<br>
